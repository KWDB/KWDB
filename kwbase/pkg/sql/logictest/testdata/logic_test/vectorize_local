# LogicTest: local-vec

statement ok
CREATE TABLE a (a INT, b INT, c INT4, PRIMARY KEY (a, b))

statement ok
CREATE TABLE c (a INT, b INT, c INT, d INT, PRIMARY KEY (a, c), INDEX sec (b))

statement ok
CREATE TABLE d (a INT, b INT, PRIMARY KEY (b, a))

statement ok
INSERT INTO a SELECT g//2, g, g FROM generate_series(0,2000) g(g)

statement ok
INSERT INTO c VALUES (1, 1, 1, 0), (2, 1, 2, 0)

statement ok
ALTER TABLE c INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1,
    "distinct_count": 1
  }
]'

statement ok
INSERT INTO d VALUES (1, 1), (1, 2)

# Test that vectorized stats are collected correctly.
statement ok
SET vectorize = on

statement ok
SET distsql = on

statement ok
SET vectorize_row_count_threshold = 0

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT a FROM a]
----
eJyMkDFP-zAUxPf_p7Bu-iMZSBADeGoFQYoU2tJkAKoMbvJULLmxsR1EVeW7o8QdYEBi8_vdvbPPR_h3DYEyK7K7ivVOs4f18pFtsudVMc8XbL6YFy-vGft_n5dV-VScsZNVRqOswdGZlhZyTx5igxQ1h3WmIe-NG9FxMuTtJ0TCoTrbhxHXHI1xBHFEUEETBCq51bQm2ZK7TMDRUpBKT7FyZp3aS3cAR2ll5wU7B8eyD4LN0niyfagOlrxgqgvX4NjK0LyRZ2bSBLsCR-it_o6SZNz2pKkJ6kOFg2DJxe3NyILUmgW1J8ESj3rgiFun1_sgdwSRDvzvDdfkrek8_SwHjl_jk6HmoHZH8Su96V1DK2ea6a44xu4TaMmHqKZxyLsoDfXw7ysAAP__3LCdsw==

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT c.a FROM c JOIN d ON d.b = c.b]
----
eJykkl-rEzEQxd_9FMM8KcS6W3wKCC1aYS_r9tr2Qb3sQ5oM12iaxCSrLaXfXXazSqvUP9zHOXNmMr9Djhi_GOS4XtSLlxvogoHXq-UbuFu8u63nVQPzZl6__7CAx6-q9Wb9tn4Co1VORLZKuFlWDShYNqAmW3gBcrJtkaF1ihqxo4j8DktsGfrgJMXoQi8dB0Ol9sgLhtr6LvVyy1C6QMiPmHQyhBw3YmtoRUJReFYgQ0VJaDOslbNIEhmuvbCRw1NkuOwSh1nJZtNc-C5tDp4iB23T8yvaViT5kSK4ocehRIap8-ZM6tdFMiST_qrTgUMxKfprYhLGQNI74lBEbE8M88hIE5O4J-Tlif078Y3TdgQuL4HVzAe9E-GADGvnPncePjltwVkOP4h7_CucwX2LEEiokefy9v4oRXs4c5U_xd-8D8iM9iS7pJ39e27T_8ltRdE7G-kyM2R4dX1xahmSuqf8JaPrgqTb4OTwVi5zkIOgKKbcLXNR2dzqrzwfLv84PP1luD09-h4AAP__VVMiaA==

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT c.a FROM c INNER MERGE JOIN d ON c.a = d.b]
----
eJzEktFr2zAQxt_3Vxz31DIttd09CQoJmzdcEqdz8rCt-EGRbqlAsTxJHg0h__uwVVg91pYMxt6ku-_T6fdxB_TfDXJc5fP83Ro6Z-BDtVzAbf75Zj4rSpiVs_mXrzmcvS9W69Wn-Tk8SOVERKmEoizzChZ59TGH62VRgoJlOQiuQE02NTJsrKJS7Mgjv8UUa4ats5K8t64vHQZBoe6RJwx103ahL9cMpXWE_IBBB0PIcS02hioSitxFggwVBaHN8Kyctk7vhNsjw1UrGs_hDTJcdoHDNI2ntgvrfUueg27CW2S4EUHekQc79Dj0utC15lEpQ4aeDMmgf-iw55BMkn60D8IYCHpHHBKP9ZFhtDx83QexJeTpkf0dXjrGU8_hZf8NL3sS7xdV11inyJEaEdW98yXJHzJakNvStdUNuYtsnJGhb-Fsmr4-v3J6exeP_3IF6J5kF7RtXs7p8pQ1qMi3tvE0pkOGTz6f9EmR2lJM3tvOSbpxVg6z4jXCDwVFPsRuFi9FM7SGZX1sTk8wZ7-bs2fNlyNzcqyPr34GAAD__3vSeKM=

statement ok
RESET vectorize; RESET distsql; RESET vectorize_row_count_threshold

statement ok
SET tracing=off

# Making sure that colBatchScan operator can parallelize scans.
# This test is similar to that in testplannerlogic/select
statement ok
CREATE TABLE tpar (
    a INT PRIMARY KEY, item STRING, price FLOAT, FAMILY (a, item, price),
    UNIQUE INDEX item (item), UNIQUE INDEX p (price)
)

statement ok
ALTER TABLE tpar SPLIT AT VALUES(5)

# Run a select to prime the range cache to simplify the trace below.
statement ok
SELECT * FROM tpar

# Make sure that the scan actually gets parallelized.
statement ok
SET tracing = on; SELECT * FROM tpar WHERE a = 0 OR a = 10; SET tracing = off

# The span "sending partial batch" means that the scan was parallelized.
# Note that table ID here is hardcoded, so if a new table is created before
# tpar, this query will need an adjustment.
query T
SELECT message FROM [SHOW TRACE FOR SESSION] WHERE message IN
    ('querying next range at /Table/81/1/0',
     'querying next range at /Table/81/1/10',
     '=== SPAN START: kv.DistSender: sending partial batch ==='
    )
----
querying next range at /Table/81/1/0
=== SPAN START: kv.DistSender: sending partial batch ===
querying next range at /Table/81/1/10

# Regression test for #46123 (rowexec.TableReader not implementing
# execinfra.OpNode interface).
statement ok
CREATE TABLE t46123(c0 INT)

query T
EXPLAIN (VEC) SELECT stddev(0) FROM t46123 WHERE ('' COLLATE en)::BOOL
----
│
└ Node 1
└ *rowexec.orderedAggregator
  └ *rowexec.tableReader

# Regression test for #46122 (checking that we gracefully fallback to row
# execution on cross joins).
statement ok
CREATE TABLE t46122_0(c0 STRING); CREATE TABLE t46122_1(c0 STRING)

query T
EXPLAIN (VEC) SELECT t46122_0.c0 FROM t46122_0, t46122_1
----
│
└ Node 1
└ *rowexec.hashJoiner
  ├ *colexec.colBatchScan
  └ *colexec.colBatchScan

# Regression test for #46404 (rowexec.noopProcessor not implementing
# execinfra.OpNode interface).
statement ok
CREATE TABLE t46404_0(c0 INT); CREATE TABLE t46404_1(c0 INT)

statement error pq: unable to vectorize execution plan: cannot use col exec when cross join
EXPLAIN (VEC) SELECT stddev((t46404_1.c0 > ANY (0, 0))::INT) FROM t46404_0, t46404_1 GROUP BY t46404_0.rowid

statement ok
CREATE TABLE xyz (
  x INT,
  y INT,
  z TEXT
)

# Check that we fallback gracefully to row-by-row engine on a join type that
# we don't support.
query T
EXPLAIN (VEC) (SELECT y FROM xyz) EXCEPT ALL (SELECT x AS y FROM xyz) ORDER BY y
----
│
└ Node 1
  └ *colexec.sortOp
    └ *rowexec.hashJoiner
      ├ *colexec.colBatchScan
      └ *colexec.colBatchScan
