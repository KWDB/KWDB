// Copyright (c) 2022-present, Shanghai Yunxi Technology Co, Ltd.
//
// This software (KWDB) is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//          http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
// EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
// MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.

// Metadata architecture builds the logical framework and basic model of KaiwuDB,
// thus determining the functional characteristics, operation mode and overall
// performance of KWDB system operation.
// KaiwuDB operates on the basis of metadata. Its main functions are: description function,
// integration function, control function and agent function.

syntax = "proto2";
package kwdbts;

// import "data.proto";
// import "descriptors.proto";
// import "status.proto";
// import "types.proto";
// import "olap_common.proto";
// import "olap_file.proto";
// import "lake_types.proto";

option cc_generic_services = true;

message PScalarType {
    // TPrimitiveType, use int32 to avoid redefine Enum
    required int32 type = 1;
    // Only set if type == CHAR or type == VARCHAR
    optional int32 len = 2;
    // Only set for DECIMAL
    optional int32 precision = 3;
    optional int32 scale = 4;
};

// Represents a field in a STRUCT type.
// TODO: Model column stats for struct fields.
message PStructField {
    required string name = 1;
    optional string comment = 2;
};

message PTypeNode {
    // TTypeNodeType(SCALAR, ARRAY, MAP, STRUCT)
    required int32 type = 1;
    // only set for scalar types
    optional PScalarType scalar_type = 2;
    // only used for structs; has struct_fields.size() corresponding child types
    repeated PStructField struct_fields = 3;
};

// A flattened representation of a tree of column types obtained by depth-first
// traversal. Complex types such as map, array and struct have child types corresponding
// to the map key/value, array item type, and struct fields, respectively.
// For scalar types the list contains only a single node.
// Note: We cannot rename this to TType because it conflicts with Thrift's internal TType
// and the generated Python thrift files will not work.
// Note: TTypeDesc in impala is TColumnType, but we already use TColumnType, so we name this
// to TTypeDesc. In future, we merge these two to one
message PTypeDesc {
    repeated PTypeNode types = 1;
};

message PUniqueId {
    required int64 hi = 1;
    required int64 lo = 2;
};

message PRowBatch {
    required int32 num_rows = 1;
    repeated int32 row_tuples = 2;
    repeated int32 tuple_offsets = 3;
    required bytes tuple_data = 4;
    required bool is_compressed = 5;
};

message PQueryStatistics {
    optional int64 scan_rows = 1;
    optional int64 scan_bytes = 2;
    optional int64 returned_rows = 3;
    optional int64 cpu_cost_ns = 4;
    optional int64 mem_cost_bytes = 5;
    optional int64 spill_bytes = 6;
    repeated QueryStatisticsItemPB stats_items = 10;
    repeated NodeExecStatsItemPB node_exec_stats_items = 11;
}

message QueryStatisticsItemPB {
    optional int64 scan_rows = 1;
    optional int64 scan_bytes = 2;
    optional int64 table_id = 3;
}

message NodeExecStatsItemPB {
    optional int64 push_rows = 1;
    optional int64 pull_rows = 2;
    optional int64 pred_filter_rows = 3;
    optional int64 index_filter_rows = 4;
    optional int64 rf_filter_rows = 5;
    optional uint32 node_id = 20;
}

message ChunkExtraColumnsMetaPB {
    optional PTypeDesc type_desc = 1;
    optional bool is_null = 2;
    optional bool is_const = 3;
};

enum CompressionTypePB {
    UNKNOWN_COMPRESSION = 0;
    DEFAULT_COMPRESSION = 1;
    NO_COMPRESSION = 2;
    SNAPPY_COMPRESSION = 3;
    LZ4_COMPRESSION = 4;
    LZ4_FRAME_COMPRESSION = 5;
    ZLIB_COMPRESSION = 6;
    ZSTD_COMPRESSION = 7;
    GZIP_COMPRESSION = 8;
    DEFLATE_COMPRESSION = 9;
    BZIP2_COMPRESSION = 10;
    LZO_COMPRESSION = 11; // Deprecated
    BROTLI_COMPRESSION = 12;
    LZ4_HADOOP_COMPRESSION = 13;
}

message ColumnPB {
    optional int64 uncompressed_size = 1;     //
    optional int64 compressed_size = 2;       // 
    optional int64 offset = 3;                // offset in data
    optional bytes data = 4;                  // column data (compress)
};

message ChunkColumnInfo {
    optional uint32 storage_len = 1;
    optional uint32 fixed_storage_len = 2;
    optional int32 storage_type = 3;
    optional int32 return_type = 4;
    optional bool is_string = 5;
    optional bool allow_null = 6;
};

message ChunkPB {
    // Content for this chunk.
    optional bytes data = 1;
    // Helper to allocate memory to decompress compressed data.
    optional int64 uncompressed_size = 2;
    optional int64 data_size = 3;    // used to record size using brpc attachment
    // For some object column types like bitmap/hll/percentile.
    // we may estimate larger serialized_size but actually don't use that much space.
    optional int64 serialized_size = 4; // how many bytes are really written into data.
    repeated ChunkColumnInfo column_info = 5; // chunk's column.
    optional bool is_encoding = 6;
    optional CompressionTypePB compress_type = 7;
    repeated ColumnPB columns = 8;//compress data
};

message StatusPB {
    required int32 status_code = 1;
    repeated string error_msgs = 2;
};

message PHttpRequest {
    optional string method = 1;
    optional string uri = 2;
    optional string version = 3;
    repeated string headers = 4;
    optional bytes body = 5;
};

// Transmit vectorized data chunks between Backends.
// Try to batch enough chunk in one request to reduce each RPC call overhead.
message PTransmitChunkParams {
    optional int64 query_id = 1;
    optional int32 target_node_id = 2;
    optional int32 sender_id = 3;
    optional int32 dest_processor = 4;
    optional bool eos = 5;
    optional int64 sequence = 6;
    repeated ChunkPB chunks = 7;
    optional bool use_pass_through = 8 [default = false];
    repeated int32 driver_sequences = 9;
    optional int32 be_number = 10;
    optional StatusPB status = 11;
};

message PTransmitChunkResult {
    optional StatusPB status = 1;
    optional int64 receive_timestamp = 2; // Deprecated
    optional int64 receiver_post_process_time = 3;
};

message PDialDataRecvr {
    optional int64 query_id = 1;
    optional int32 dest_processor = 2;
};

message PDialDataRecvrResult {
    optional StatusPB status = 1;
};

enum ExecStatus {
    EXEC_STATUS_SUCCESS = 0;
    EXEC_STATUS_FAILED = 1;
}

message PSendExecStatus {
    optional int64 query_id = 1;
    optional int32 dest_processor = 2;
    optional ExecStatus exec_status = 3;
    optional int32 error_code = 4;
    optional string error_msg = 5;
};

message PSendExecStatusResult {
    optional StatusPB status = 1;
};

service BoxService {
    // Transmit vectorized data between backends.
    rpc DialDataRecvr(PDialDataRecvr) returns (PDialDataRecvrResult);
    rpc TransmitChunk(PTransmitChunkParams) returns (PTransmitChunkResult);
    rpc SendExecStatus(PSendExecStatus) returns (PSendExecStatusResult);
};
