> create ts database test_vacuum;
CREATE TS DATABASE
> create table test_vacuum.t1 (k_timestamp timestamptz not null,id int not null,e1 int2,e2 int,e3 int8,e4 float4,e5 float8,e6 bool,e7 timestamptz,e8 char(1023),e9 nchar(255),e10 varchar(4096),e11 char,e12 char(255),e13 nchar,e14 nvarchar(4096),e15 varchar(1023),e16 nvarchar(200),e17 nchar(255),e18 char(200),e19 varbytes,e20 varbytes(60),e21 varchar,e22 nvarchar) tags (code1 int2 not null,code2 int,code3 int8,code4 float4,code5 float8,code6 bool,code7 varchar,code8 varchar(128) not null,code9 varbytes,code10 varbytes(60),code11 varchar,code12 varchar(60),code13 char(2),code14 char(1023) not null,code15 nchar,code16 nchar(254) not null) primary tags (code1) activetime 2d partition interval 1d;
CREATE TABLE
> set cluster setting ts.parallel_degree = 8;
SET CLUSTER SETTING
> set statement_timeout='10s';
SET
> use test_vacuum;
SET
> select
  subq_0.c8 as c0,
  ref_6.e19 as c1,
  (select e7 from public.t1 limit 1 offset 5)
     as c2,
  ref_19.code14 as c3,
  65 as c4,
  ref_20.e14 as c5,
  ref_21.e2 as c6,
  cast(coalesce(ref_17.e1,
    ref_2.code1) as int2) as c7,
  ref_0.code15 as c8,
  ref_21.e19 as c9
from
  public.t1 as ref_0
            right join public.t1 as ref_1
            on ((ref_1.e11 is not NULL)
                or (false))
          inner join public.t1 as ref_2
            left join public.t1 as ref_3
            on (false)
          on (((cast(null as _text) IS NOT DISTINCT FROM cast(null as _text))
                or (ref_1.e6 >= ref_0.e6))
              and (((select code12 from public.t1 limit 1 offset 3)
                     is not NULL)
                or (cast(null as text) IS DISTINCT FROM cast(null as text))))
        inner join public.t1 as ref_4
              inner join public.t1 as ref_5
              on (ref_4.code3 <= cast(null as "numeric"))
            left join public.t1 as ref_6
              left join public.t1 as ref_7
              on ((cast(null as _date) > cast(null as _date))
                  and ((cast(null as _float8) <= cast(null as _float8))
                    and (cast(null as "timetz") > cast(null as "time"))))
            on (cast(null as date) != cast(null as date))
          inner join public.t1 as ref_8
          on (EXISTS (
              select
                  ref_5.e15 as c0
                from
                  public.t1 as ref_9
                where cast(null as _bool) = cast(null as _bool)
                limit 93))
        on (EXISTS (
            select
                ref_3.e17 as c0,
                ref_7.e14 as c1,
                ref_10.id as c2
              from
                public.t1 as ref_10
              where (ref_7.e11 is not NULL)
                and ((ref_6.e6 != ref_2.e6)
                  and (false))
              limit 90))
      inner join public.t1 as ref_11
          inner join public.t1 as ref_12
          on (ref_11.id = ref_12.id )
        inner join (select
                ref_13.e22 as c0,
                ref_13.e13 as c1,
                ref_13.e17 as c2,
                ref_13.e7 as c3,
                ref_13.e5 as c4,
                (select e20 from public.t1 limit 1 offset 73)
                   as c5,
                ref_13.e2 as c6,
                ref_13.code6 as c7,
                ref_13.code10 as c8,
                ref_13.e17 as c9,
                ref_13.e14 as c10
              from
                public.t1 as ref_13
              where ref_13.e19 is not NULL
              limit 54) as subq_0
          left join public.t1 as ref_14
          on (EXISTS (
              select
                  (select code2 from public.t1 limit 1 offset 1)
                     as c0,
                  ref_15.e3 as c1,
                  ref_14.code16 as c2,
                  ref_14.e18 as c3,
                  subq_0.c7 as c4
                from
                  public.t1 as ref_15
                where false
                limit 169))
        on (ref_12.e6 = ref_14.e6 )
      on ((ref_14.e7 is not NULL)
          and (cast(null as _uuid) > cast(null as _uuid)))
    right join public.t1 as ref_16
        left join public.t1 as ref_17
          inner join public.t1 as ref_18
          on (ref_17.code16 = ref_18.e9 )
        on (cast(null as "time") <= cast(null as "timetz"))
      inner join public.t1 as ref_19
          right join public.t1 as ref_20
            inner join public.t1 as ref_21
            on (ref_20.code3 IS DISTINCT FROM ref_20.code5)
          on (cast(null as _time) != cast(null as _time))
        left join public.t1 as ref_22
        on (cast(null as float8) != ref_22.code5)
      on (cast(coalesce(cast(null as text),
            cast(null as text)) as text) < cast(null as text))
    on (cast(null as text) IS DISTINCT FROM pg_catalog.getdatabaseencoding())
where case when ((EXISTS (
          select
              ref_14.code6 as c0,
              ref_14.e22 as c1,
              ref_18.code15 as c2,
              (select e14 from public.t1 limit 1 offset 5)
                 as c3,
              ref_3.e6 as c4,
              subq_0.c8 as c5,
              ref_8.e1 as c6,
              ref_8.code3 as c7
            from
              public.t1 as ref_23
                inner join public.t1 as ref_24
                on (ref_23.code4 = ref_24.e4 )
            where EXISTS (
              select
                  ref_1.e5 as c0,
                  83 as c1
                from
                  public.t1 as ref_25
                where cast(null as _jsonb) <= cast(null as _jsonb)
                limit 142)
            limit 35))
        or (EXISTS (
          select
              ref_1.e18 as c0,
              ref_5.k_timestamp as c1,
              subq_0.c6 as c2,
              4 as c3
            from
              public.t1 as ref_26
            where cast(null as "timestamp") <= cast(null as "timestamp"))))
      or (cast(nullif(cast(null as bytea),
          case when cast(null as "time") >= cast(null as "time") then cast(null as bytea) else cast(null as bytea) end
            ) as bytea) >= cast(null as bytea)) then case when cast(null as "interval") > cast(null as "interval") then case when false then case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           else case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           end
         else case when false then case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           else case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           end
         end
       else case when cast(null as "interval") > cast(null as "interval") then case when false then case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           else case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           end
         else case when false then case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           else case when ref_22.code1 = ref_6.code1 then pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) else pg_catalog.subbit(
            cast(ref_16.code3 as int8),
            cast(ref_3.code3 as int8),
            cast(ref_12.e3 as int8)) end
           end
         end
       end
     = case when (EXISTS (
        select
            ref_11.code4 as c0,
            ref_11.e12 as c1,
            ref_3.e12 as c2,
            ref_22.code7 as c3,
            ref_4.code2 as c4,
            ref_8.code1 as c5,
            ref_3.code6 as c6,
            ref_3.code15 as c7
          from
            public.t1 as ref_27
          where true
          limit 51))
      and (EXISTS (
        select
            97 as c0,
            subq_1.c4 as c1,
            ref_20.code5 as c2,
            subq_2.c4 as c3
          from
            public.t1 as ref_28,
            lateral (select
                  ref_17.e22 as c0,
                  subq_0.c8 as c1,
                  ref_4.e10 as c2,
                  ref_5.id as c3,
                  subq_0.c6 as c4,
                  74 as c5,
                  ref_14.e18 as c6,
                  ref_12.code5 as c7,
                  19 as c8,
                  (select e14 from public.t1 limit 1 offset 44)
                     as c9
                from
                  public.t1 as ref_29
                where ref_2.e3 IS DISTINCT FROM ref_17.code5
                limit 179) as subq_1,
            lateral (select
                  ref_2.e22 as c0,
                  ref_11.e21 as c1,
                  ref_28.code15 as c2,
                  ref_12.e19 as c3,
                  ref_2.e3 as c4,
                  ref_18.code2 as c5
                from
                  public.t1 as ref_30
                where cast(null as _interval) < cast(null as _interval)
                limit 108) as subq_2
          where ref_5.code6 is NULL)) then pg_catalog.rightbit(
      cast(cast(coalesce(ref_14.e6,
        ref_22.code6) as bool) as bool),
      cast(ref_1.e3 as int8)) else pg_catalog.rightbit(
      cast(cast(coalesce(ref_14.e6,
        ref_22.code6) as bool) as bool),
      cast(ref_1.e3 as int8)) end

limit 132;
  c0 | c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 | c9
-----+----+----+----+----+----+----+----+----+-----
(0 rows)
> drop database test_vacuum cascade;
DROP DATABASE
> create ts database test_vacuum;
CREATE TS DATABASE
> create table test_vacuum.t1 (k_timestamp timestamptz not null,id int not null,e1 int2,e2 int,e3 int8,e4 float4,e5 float8,e6 bool,e7 timestamptz,e8 char(1023),e9 nchar(255),e10 varchar(4096),e11 char,e12 char(255),e13 nchar,e14 nvarchar(4096),e15 varchar(1023),e16 nvarchar(200),e17 nchar(255),e18 char(200),e19 varbytes,e20 varbytes(60),e21 varchar,e22 nvarchar) tags (code1 int2 not null,code2 int,code3 int8,code4 float4,code5 float8,code6 bool,code7 varchar,code8 varchar(128) not null,code9 varbytes,code10 varbytes(60),code11 varchar,code12 varchar(60),code13 char(2),code14 char(1023) not null,code15 nchar,code16 nchar(254) not null) primary tags (code1) activetime 2d partition interval 1d;
CREATE TABLE
> set cluster setting ts.parallel_degree = 8;
SET CLUSTER SETTING
> set statement_timeout='10s';
SET
> WITH
jennifer_0 AS (select
ref_2.id as c0
from
test_vacuum.t1 as ref_0
inner join (select
ref_1.e8 as c0,
ref_1.code3 as c1
from
test_vacuum.t1 as ref_1
where true
limit 128) as subq_0
inner join test_vacuum.t1 as ref_2
on (subq_0.c1 = ref_2.e3 )
on (ref_0.code9 is NULL)
where ((pg_catalog.timezone(cast(null as text), ref_0.e7) >= pg_catalog.current_timestamp())
or (EXISTS (
select
subq_0.c0 as c0,
ref_0.code2 as c1,
ref_2.e13 as c2,
ref_3.e10 as c3
from
test_vacuum.t1 as ref_3
left join test_vacuum.t1 as ref_4
on (EXISTS (
select
ref_5.code5 as c0
from
test_vacuum.t1 as ref_5
where ((false)
or (cast(null as _uuid) < cast(null as _uuid)))
and (ref_0.e22 is NULL)))
where cast(null as date) IS NOT DISTINCT FROM cast(null as "timestamp")
limit 147)))
and (((EXISTS (
select
ref_2.e11 as c0,
ref_6.e9 as c1,
ref_6.id as c2,
ref_0.e22 as c3,
ref_2.e18 as c4,
ref_2.e21 as c5,
(select e8 from test_vacuum.t1 limit 1 offset 5)
as c6
from
test_vacuum.t1 as ref_6
right join test_vacuum.t1 as ref_7
on (cast(null as "numeric") < cast(null as "numeric"))
where (false)
or (EXISTS (
select
71 as c0,
ref_2.e13 as c1
from
test_vacuum.t1 as ref_8
where cast(null as date) > cast(null as "timestamp")
limit 18))
limit 25))
or (false))
or (cast(null as _int8) != pg_catalog.array_positions(cast(nullif(cast(null as _float8),
cast(null as _float8)) as _float8), ref_0.e5)))
limit 130)
select
subq_1.c0 as c0,
cast(coalesce(subq_1.c3,
subq_2.c5) as int4) as c1,
(select code9 from test_vacuum.t1 limit 1 offset 4)
as c2,
subq_1.c2 as c3,
79 as c4,
subq_1.c0 as c5,
subq_1.c1 as c6,
subq_1.c2 as c7,
subq_1.c2 as c8
from
(select
ref_11.c0 as c0,
ref_11.c0 as c1,
ref_12.c0 as c2,
30 as c3
from
jennifer_0 as ref_9
inner join test_vacuum.t1 as ref_10
inner join jennifer_0 as ref_11
on (ref_10.code2 = ref_11.c0 )
inner join jennifer_0 as ref_12
on (ref_12.c0 is not NULL)
on (ref_10.code5 != ref_10.e5)
where ref_12.c0 is not NULL
limit 127) as subq_1
inner join (select
ref_13.id as c0,
ref_13.code16 as c1,
ref_13.e22 as c2,
ref_13.id as c3,
ref_13.code2 as c4,
10 as c5,
ref_13.e11 as c6,
ref_13.code9 as c7,
ref_13.e11 as c8,
ref_13.code3 as c9,
ref_13.e8 as c10,
ref_13.e8 as c11,
ref_13.e4 as c12,
ref_13.e2 as c13,
ref_13.e18 as c14,
ref_13.e1 as c15,
1 as c16,
ref_13.code10 as c17,
ref_13.e3 as c18,
ref_13.e8 as c19,
ref_13.code7 as c20
from
test_vacuum.t1 as ref_13
where EXISTS (
select
ref_14.c0 as c0
from
jennifer_0 as ref_14
where ref_14.c0 is NULL)
limit 118) as subq_2
on (subq_1.c2 is not NULL)
where EXISTS (
select
subq_1.c0 as c0,
subq_4.c1 as c1,
case when false then subq_2.c3 else subq_2.c3 end
as c2,
subq_1.c3 as c3,
(select e1 from test_vacuum.t1 limit 1 offset 3)
as c4,
subq_4.c1 as c5,
ref_18.e18 as c6,
ref_17.e17 as c7,
subq_2.c3 as c8,
ref_18.e8 as c9,
subq_4.c2 as c10,
subq_1.c2 as c11,
ref_18.code11 as c12,
subq_4.c0 as c13
from
jennifer_0 as ref_15
left join test_vacuum.t1 as ref_16
on (false)
right join test_vacuum.t1 as ref_17
on (cast(null as "interval") != cast(null as "interval"))
inner join test_vacuum.t1 as ref_18
on (true)
inner join (select distinct
subq_2.c2 as c0,
subq_1.c1 as c1,
subq_2.c14 as c2
from
test_vacuum.t1 as ref_19,
lateral (select
ref_19.e9 as c0,
ref_19.e21 as c1,
ref_19.k_timestamp as c2,
ref_20.code8 as c3,
38 as c4,
subq_1.c0 as c5,
subq_1.c1 as c6,
subq_2.c15 as c7,
ref_19.e17 as c8,
subq_1.c3 as c9,
76 as c10,
ref_19.k_timestamp as c11,
ref_20.e4 as c12,
subq_2.c10 as c13,
72 as c14
from
test_vacuum.t1 as ref_20
where true
limit 181) as subq_3
where cast(null as uuid) < cast(null as uuid)
limit 108) as subq_4
on (ref_17.e18 = subq_4.c2 )
where (((cast(null as uuid) <= cast(null as uuid))
or (cast(null as _uuid) IS NOT DISTINCT FROM cast(null as _uuid)))
or (cast(null as "timetz") < cast(null as "timetz")))
or ((cast(null as text) !~ cast(null as text))
and (cast(null as "varbit") = cast(null as "varbit"))))
limit 86
;
  c0 | c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8
-----+----+----+----+----+----+----+----+-----
(0 rows)
> select
  subq_0.c1 as c0,
  subq_0.c4 as c1,
  case when pg_catalog.localtimestamp() > pg_catalog.experimental_follower_read_timestamp() then subq_0.c0 else subq_0.c0 end
     as c2,
  subq_0.c4 as c3,
  case when pg_catalog.inet_server_addr() > pg_catalog.inet_server_addr() then subq_0.c2 else subq_0.c2 end
     as c4,
  cast(coalesce(subq_0.c0,
    pg_catalog.bpcharin(
        pg_catalog.min_extend((select e6 from test_vacuum.t1 limit 1 offset 4)
            , cast(null as int8)) over (partition by subq_0.c3,subq_0.c0 order by subq_0.c1))) as bpchar) as c5,
  case when true then case when subq_0.c1 is NULL then subq_0.c2 else subq_0.c2 end
       else case when subq_0.c1 is NULL then subq_0.c2 else subq_0.c2 end
       end
     as c6,
  54 as c7,
  subq_0.c3 as c8,
  subq_0.c2 as c9,
  subq_0.c1 as c10
from
  (select
        ref_2.e11 as c0,
        ref_2.e10 as c1,
        ref_2.e1 as c2,
        ref_3.e19 as c3,
        ref_4.code7 as c4
      from
        test_vacuum.t1 as ref_0
          inner join test_vacuum.t1 as ref_1
                right join test_vacuum.t1 as ref_2
                on (46 is not NULL)
              right join test_vacuum.t1 as ref_3
              on ((ref_1.code5 <= ref_3.e3)
                  or (true))
            inner join test_vacuum.t1 as ref_4
            on (cast(null as "timetz") <= cast(null as "timetz"))
          on ((cast(null as _date) = cast(null as _date))
              and ((cast(null as text) !~ cast(null as text))
                or ((false)
                  and (ref_3.e9 is NULL))))
      where (cast(null as "interval") >= cast(null as "interval"))
        or (false)
      limit 99) as subq_0
where pg_catalog.kwdb_internal.cluster_id() != pg_catalog.kwdb_internal.cluster_id()
limit 95;
ERROR: min_extend(): function reserved for internal use
SQLSTATE: 42939
> drop database test_vacuum cascade;
DROP DATABASE
> create ts database db_shig;
CREATE TS DATABASE
> use db_shig;
SET
> CREATE TABLE t_electmeter (
	k_timestamp TIMESTAMPTZ NOT NULL,
	elect_name VARCHAR(63) NOT NULL,
	vol_a FLOAT8 NOT NULL,
	cur_a FLOAT8 NOT NULL,
	powerf_a FLOAT8 NULL,
	allenergy_a INT4 NOT NULL,
	pallenergy_a INT4 NOT NULL,
	rallenergy_a INT4 NOT NULL,
	allrenergy1_a INT4 NOT NULL,
	allrenergy2_a INT4 NOT NULL,
	powera_a FLOAT8 NOT NULL,
	powerr_a FLOAT8 NOT NULL,
	powerl_a FLOAT8 NOT NULL,
	vol_b FLOAT8 NOT NULL,
	cur_b FLOAT8 NOT NULL,
	powerf_b FLOAT8 NOT NULL,
	allenergy_b INT4 NOT NULL,
	pallenergy_b INT4 NOT NULL,
	rallenergy_b INT4 NOT NULL,
	allrenergy1_b INT4 NOT NULL,
	allrenergy2_b INT4 NOT NULL,
	powera_b FLOAT8 NOT NULL,
	powerr_b FLOAT8 NOT NULL,
	powerl_b FLOAT8 NOT NULL,
	vol_c FLOAT8 NOT NULL,
	cur_c FLOAT8 NOT NULL,
	powerf_c FLOAT8 NOT NULL,
	allenergy_c INT4 NOT NULL,
	pallenergy_c INT4 NOT NULL,
	rallenergy_c INT4 NOT NULL,
	allrenergy1_c INT4 NOT NULL,
	allrenergy2_c INT4 NOT NULL,
	powera_c FLOAT8 NOT NULL,
	powerr_c FLOAT8 NOT NULL,
	powerl_c FLOAT8 NOT NULL,
	vol_ab FLOAT8 NULL,
	vol_bc FLOAT8 NULL,
	vol_ca FLOAT8 NULL,
	infre FLOAT8 NOT NULL,
	powerf FLOAT8 NOT NULL,
	allpower FLOAT8 NOT NULL,
	pallpower FLOAT8 NOT NULL,
	rallpower FLOAT8 NOT NULL,
	powerr FLOAT8 NOT NULL,
	powerl FLOAT8 NOT NULL,
	allrenergy1 FLOAT8 NOT NULL,
	allrenergy2 FLOAT8 NOT NULL
) TAGS (
	machine_code VARCHAR(64) NOT NULL,
	op_group VARCHAR(64) NOT NULL,
	location VARCHAR(64) NOT NULL,
	cnc_number INT4 ) PRIMARY TAGS(machine_code)
	retentions 0s
	activetime 3h
	partition interval 10d;
CREATE TABLE
> CREATE TABLE up_exg_msg_real_location (
	gtime TIMESTAMPTZ NOT NULL,
	data VARCHAR(255) NULL,
	data_len INT4 NULL,
	data_type INT4 NULL,
	ban_on_driving_warning INT4 NULL,
	camera_error INT4 NULL,
	collision_rollover INT4 NULL,
	cumulative_driving_timeout INT4 NULL,
	driver_fatigue_monitor INT4 NULL,
	early_warning INT4 NULL,
	emergency_alarm INT4 NULL,
	fatigue_driving INT4 NULL,
	gnss_antenna_disconnect INT4 NULL,
	gnss_antenna_short_circuit INT4 NULL,
	gnss_module_error INT4 NULL,
	ic_module_error INT4 NULL,
	illegal_ignition INT4 NULL,
	illegal_move INT4 NULL,
	in_out_area INT4 NULL,
	in_out_route INT4 NULL,
	lane_departure_error INT4 NULL,
	oil_error INT4 NULL,
	over_speed INT4 NULL,
	overspeed_warning INT4 NULL,
	road_driving_timeout INT4 NULL,
	rollover_warning INT4 NULL,
	stolen INT4 NULL,
	stop_timeout INT4 NULL,
	terminal_lcd_error INT4 NULL,
	terminal_main_power_failure INT4 NULL,
	terminal_main_power_under_v INT4 NULL,
	tts_module_error INT4 NULL,
	vss_error INT4 NULL,
	altitude INT4 NULL,
	date_time VARCHAR(32) NULL,
	direction INT4 NULL,
	encrypy INT4 NULL,
	lat FLOAT8 NULL,
	lon FLOAT8 NULL,
	acc INT4 NULL,
	door INT4 NULL,
	electric_circuit INT4 NULL,
	forward_collision_warning INT4 NULL,
	lane_departure_warning INT4 NULL,
	lat_state INT4 NULL,
	lat_lon_encryption INT4 NULL,
	load_rating INT4 NULL,
	location INT4 NULL,
	lon_state INT4 NULL,
	oil_path INT4 NULL,
	operation INT4 NULL,
	vec1 INT4 NULL,
	vec2 INT4 NULL,
	vec3 INT4 NULL,
	src_type INT4 NULL
) TAGS (
	vehicle_color INT4,
	vehicle_no VARCHAR(32) NOT NULL ) PRIMARY TAGS(vehicle_no)
	retentions 0s
	activetime 1d
	partition interval 10d;
CREATE TABLE
> create database tpcc;
CREATE DATABASE
> use tpcc;
SET
> CREATE TABLE bmsql_warehouse (
        w_id INT4 NOT NULL,
        w_ytd DECIMAL(12,2) NULL,
        w_tax DECIMAL(4,4) NULL,
        w_name VARCHAR(10) NULL,
        w_street_1 VARCHAR(20) NULL,
        w_street_2 VARCHAR(20) NULL,
        w_city VARCHAR(20) NULL,
        w_state CHAR(2) NULL,
        w_zip CHAR(9) NULL,
        CONSTRAINT "primary" PRIMARY KEY (w_id ASC),
        FAMILY "primary" (w_id, w_ytd, w_tax, w_name, w_street_1, w_street_2, w_city, w_state, w_zip)
);
CREATE TABLE
> CREATE TABLE bmsql_stock (
        s_i_id INT4 NOT NULL,
        s_w_id INT4 NOT NULL,
        s_quantity INT4 NULL,
        s_ytd INT4 NULL,
        s_order_cnt INT4 NULL,
        s_remote_cnt INT4 NULL,
        s_data VARCHAR(50) NULL,
        s_dist_01 CHAR(24) NULL,
        s_dist_02 CHAR(24) NULL,
        s_dist_03 CHAR(24) NULL,
        s_dist_04 CHAR(24) NULL,
        s_dist_05 CHAR(24) NULL,
        s_dist_06 CHAR(24) NULL,
        s_dist_07 CHAR(24) NULL,
        s_dist_08 CHAR(24) NULL,
        s_dist_09 CHAR(24) NULL,
        s_dist_10 CHAR(24) NULL,
        CONSTRAINT "primary" PRIMARY KEY (s_w_id ASC, s_i_id ASC),
        INDEX bmsql_stock_idx1 (s_i_id ASC),
        FAMILY "primary" (s_i_id, s_w_id, s_quantity, s_ytd, s_order_cnt, s_remote_cnt, s_data, s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10)
);
CREATE TABLE
> CREATE TABLE bmsql_oorder (
        o_id INT4 NOT NULL,
        o_w_id INT4 NOT NULL,
        o_d_id INT4 NOT NULL,
        o_c_id INT4 NULL,
        o_carrier_id INT4 NULL,
        o_ol_cnt INT4 NULL,
        o_all_local INT4 NULL,
        o_entry_d TIMESTAMP NULL,
        CONSTRAINT "primary" PRIMARY KEY (o_w_id ASC, o_d_id ASC, o_id ASC),
        UNIQUE INDEX bmsql_oorder_idx1 (o_w_id ASC, o_d_id ASC, o_carrier_id ASC, o_id ASC),
        INDEX bmsql_oorder_idx2 (o_w_id ASC, o_d_id ASC, o_c_id ASC),
        FAMILY "primary" (o_id, o_w_id, o_d_id, o_c_id, o_carrier_id, o_ol_cnt, o_all_local, o_entry_d)
);
CREATE TABLE
> CREATE TABLE bmsql_history (
        hist_id INT4 NULL,
        h_c_id INT4 NULL,
        h_c_d_id INT4 NULL,
        h_c_w_id INT4 NULL,
        h_d_id INT4 NULL,
        h_w_id INT4 NULL,
        h_date TIMESTAMP NULL,
        h_amount DECIMAL(6,2) NULL,
        h_data VARCHAR(24) NULL,
        INDEX bmsql_history_idx1 (h_c_w_id ASC, h_c_d_id ASC, h_c_id ASC),
        INDEX bmsql_history_idx2 (h_w_id ASC, h_d_id ASC),
        FAMILY "primary" (hist_id, h_c_id, h_c_d_id, h_c_w_id, h_d_id, h_w_id, h_date, h_amount, h_data, rowid)
);
CREATE TABLE
> CREATE TABLE bmsql_district (
        d_id INT4 NOT NULL,
        d_w_id INT4 NOT NULL,
        d_ytd DECIMAL(12,2) NULL,
        d_tax DECIMAL(4,4) NULL,
        d_next_o_id INT4 NULL,
        d_name VARCHAR(10) NULL,
        d_street_1 VARCHAR(20) NULL,
        d_street_2 VARCHAR(20) NULL,
        d_city VARCHAR(20) NULL,
        d_state CHAR(2) NULL,
        d_zip CHAR(9) NULL,
        CONSTRAINT "primary" PRIMARY KEY (d_w_id ASC, d_id ASC),
        FAMILY "primary" (d_id, d_w_id, d_ytd, d_tax, d_next_o_id, d_name, d_street_1, d_street_2, d_city, d_state, d_zip)
);
CREATE TABLE
> select
subq_2.c0 as c0
from
(select
ref_0.location as c0,
ref_0.cur_a as c1,
ref_0.allrenergy1_b as c2,
100 as c3,
ref_0.allrenergy2 as c4,
ref_0.pallenergy_b as c5,
ref_0.powera_b as c6,
ref_0.cur_c as c7
from
db_shig.t_electmeter as ref_0
where (cast(null as text) ~* cast(null as text))
or ((select vol_a from db_shig.t_electmeter limit 1 offset 6)
IS NOT DISTINCT FROM cast(null as "numeric"))) as subq_0
inner join (select
ref_1.w_street_2 as c0
from
tpcc.bmsql_warehouse as ref_1,
lateral (select
ref_2.s_w_id as c0,
ref_1.w_state as c1,
ref_2.s_dist_09 as c2,
ref_2.s_dist_04 as c3
from
tpcc.bmsql_stock as ref_2
where (cast(null as _inet) < cast(null as _inet))
or (ref_1.w_street_2 is NULL)
limit 70) as subq_1
where subq_1.c3 is not NULL
limit 136) as subq_2
inner join (select
ref_3.s_dist_03 as c0,
ref_4.s_dist_08 as c1,
ref_4.s_dist_03 as c2,
ref_3.s_dist_04 as c3,
ref_3.s_dist_02 as c4,
(select o_all_local from tpcc.bmsql_oorder limit 1 offset 2)
as c5,
ref_4.s_dist_05 as c6,
ref_5.h_amount as c7,
ref_4.s_dist_10 as c8,
ref_3.s_dist_07 as c9
from
tpcc.bmsql_stock as ref_3
right join tpcc.bmsql_stock as ref_4
on (cast(null as "time") != cast(null as "timetz"))
inner join tpcc.bmsql_history as ref_5
on (ref_3.s_order_cnt = ref_5.hist_id )
where (true)
and ((ref_3.s_w_id is not NULL)
or ((EXISTS (
select
ref_4.s_dist_01 as c0,
ref_4.s_dist_04 as c1,
ref_3.s_dist_09 as c2,
ref_3.s_dist_10 as c3,
ref_4.s_data as c4,
ref_3.s_order_cnt as c5,
ref_5.h_c_id as c6,
ref_6.o_carrier_id as c7,
ref_6.o_id as c8,
ref_5.h_date as c9,
ref_5.h_c_id as c10,
ref_4.s_dist_01 as c11,
ref_4.s_w_id as c12,
ref_4.s_dist_09 as c13,
ref_4.s_dist_06 as c14
from
tpcc.bmsql_oorder as ref_6
where (ref_3.s_order_cnt is NULL)
or (ref_6.o_d_id is NULL)))
and ((ref_5.h_date >= ref_5.h_date)
and (cast(null as _oid) <= cast(null as _oid)))))
limit 69) as subq_3
on (cast(null as "timetz") IS NOT DISTINCT FROM cast(null as "timetz"))
on (subq_0.c0 = subq_2.c0 )
where EXISTS (
select
subq_0.c1 as c0
from
(select
ref_7.in_out_route as c0,
subq_2.c0 as c1,
subq_3.c8 as c2,
ref_7.oil_path as c3,
subq_0.c5 as c4,
subq_0.c2 as c5,
subq_0.c4 as c6,
subq_3.c4 as c7
from
db_shig.up_exg_msg_real_location as ref_7
where cast(null as inet) >> cast(null as inet)
limit 46) as subq_4
left join tpcc.bmsql_district as ref_8
inner join tpcc.bmsql_warehouse as ref_9
on (true)
on (ref_8.d_ytd is not NULL)
where subq_3.c4 is not NULL
limit 103)
limit 44;
  c0
------
(0 rows)
> drop database tpcc cascade;
DROP DATABASE
> drop database db_shig cascade;
DROP DATABASE
