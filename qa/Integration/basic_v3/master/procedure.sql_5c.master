> drop database if exists procedure_db;
DROP DATABASE
> create database procedure_db;
CREATE DATABASE
> use procedure_db;
SET
> create table t1(a int, b int);
CREATE TABLE
> create table t2(a int, b int, c int);
CREATE TABLE
> insert into t1 values (1, 2), (3, 4);
INSERT 2
> insert into t2 values (1, 2, 3), (4, 5, 6);
INSERT 2
> create table t3(a int, b int, c int);
CREATE TABLE
> create table t4(a int);
CREATE TABLE
> create procedure p1() 
begin 
	select * from t1; 
	select * from t2; 
	select * from t3; 
	declare out_o_entry_d timestamp(3); 
	SELECT CURRENT_TIMESTAMP(3) INTO out_o_entry_d;
	select out_o_entry_d; 
end ;
CREATE PROCEDURE
> call p1();
  a | b
----+----
  1 | 2
  3 | 4
(2 rows)
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
(error encountered after some results were delivered)
ERROR: variable out_o_entry_d type timestamp(3) not save type timestamptz(9) 
SQLSTATE: 42804
> drop procedure p1;
DROP PROCEDURE
> create procedure p2() begin declare out_o_entry_d timestamp(3); SELECT CURRENT_TIMESTAMP(3) INTO out_o_entry_d;select out_o_entry_d;end ;
CREATE PROCEDURE
> call p2();
ERROR: variable out_o_entry_d type timestamp(3) not save type timestamptz(9) 
SQLSTATE: 42804
> drop procedure p2;
DROP PROCEDURE
> create procedure p4() begin select * from t1; select * from t2;declare out_o_entry_d timestamp(3); SELECT CURRENT_TIMESTAMP(3) INTO out_o_entry_d; select out_o_entry_d; end ;
CREATE PROCEDURE
> call p4();
  a | b
----+----
  1 | 2
  3 | 4
(2 rows)
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
(error encountered after some results were delivered)
ERROR: variable out_o_entry_d type timestamp(3) not save type timestamptz(9) 
SQLSTATE: 42804
> drop procedure p4;
DROP PROCEDURE
> create procedure p5() begin select * from t3; select * from t4;end ;
CREATE PROCEDURE
> call p5();
--
(0 rows)
> drop procedure p5;
DROP PROCEDURE
> create procedure p6() begin select * from t3; declare out_o_entry_d timestamp(3); SELECT CURRENT_TIMESTAMP(3) INTO out_o_entry_d; select out_o_entry_d; end;
CREATE PROCEDURE
> call p6();
ERROR: variable out_o_entry_d type timestamp(3) not save type timestamptz(9) 
SQLSTATE: 42804
> drop procedure p6;
DROP PROCEDURE
> create procedure p7() begin select * from t3; select * from t1;declare out_o_entry_d timestamp(3);SELECT CURRENT_TIMESTAMP(3) INTO out_o_entry_d;select out_o_entry_d;end ;
CREATE PROCEDURE
> call p7();
  a | b
----+----
  1 | 2
  3 | 4
(2 rows)
(error encountered after some results were delivered)
ERROR: variable out_o_entry_d type timestamp(3) not save type timestamptz(9) 
SQLSTATE: 42804
> drop procedure p7;
DROP PROCEDURE
> create procedure p8() begin select * from t3; select * from t1; end ;
CREATE PROCEDURE
> call p8();
  a | b
----+----
  1 | 2
  3 | 4
(2 rows)
> drop procedure p8;
DROP PROCEDURE
> create procedure p9() begin select * from t2; select * from t1; end;
CREATE PROCEDURE
> call p9();
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
  a | b
----+----
  1 | 2
  3 | 4
(2 rows)
> drop procedure p9;
DROP PROCEDURE
> create procedure p2() begin declare a int;declare d int; set d = 10; select a,b,d from t1; end;
CREATE PROCEDURE
> call p2();
  a | b | d
----+---+-----
  1 | 2 | 10
  3 | 4 | 10
(2 rows)
> drop procedure p2;
DROP PROCEDURE
> create procedure p2() begin declare d int; set d = 10; insert into t1  (a) values (d); end;
CREATE PROCEDURE
> call p2();
CALL PROCEDURE
> drop procedure p2;
DROP PROCEDURE
> create procedure p3() begin declare a int;declare d int; set d = 10; select a,b,d from t1 where d < 10; end;
CREATE PROCEDURE
> call p3();
--
(0 rows)
> drop procedure p3;
DROP PROCEDURE
> create procedure p4() begin declare a int;declare d int; set d = 5; select a,b,d from t1 where d < 10; end;
CREATE PROCEDURE
> call p4();
  a  |  b   | d
-----+------+----
   1 |    2 | 5
   3 |    4 | 5
  10 | NULL | 5
(3 rows)
> drop procedure p4;
DROP PROCEDURE
> CREATE PROCEDURE p3(a INT4)  BEGIN DECLARE b INT4; declare c int4;declare c1 cursor for select a from t1 ; open c1;delete from t1 where a = 1;fetch c1 into b;fetch c1 into c;close c1 ;select b;select c;END;
CREATE PROCEDURE
> call p3(1);
  b
-----
  1
(1 row)
  c
-----
  3
(1 row)
> drop procedure p3;
DROP PROCEDURE
> CREATE PROCEDURE p5(a INT4)  BEGIN update t1  set a = b -1 where a <4;END;
CREATE PROCEDURE
> call p5(1);
CALL PROCEDURE
> drop procedure p5;
DROP PROCEDURE
> create procedure test10(a int, b int) begin select * from t1;select * from t2; end;
CREATE PROCEDURE
> call test10(1,2);
  a  |  b
-----+-------
   3 |    4
  10 | NULL
(2 rows)
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
> drop procedure test10;
DROP PROCEDURE
> create procedure test20(a int, b int) begin select 1;select 2; end;
CREATE PROCEDURE
> call test20(1,2);
  ?column?
------------
         1
(1 row)
  ?column?
------------
         2
(1 row)
> drop procedure test20;
DROP PROCEDURE
> create procedure test() label test: begin declare a int default 0; declare b int default 0; declare err int default 0; declare exit HANDLER FOR NOT FOUND,SQLEXCEPTION BEGIN SET err = -1;SELECT a,b;ROLLBACK;ENDHANDLER;START TRANSACTION;set a = 10;select a, b, 'this is t1 values' from t1;update t1 set a =  a + 1 where b > 0;insert into t1 values (a, b);label my_loop:WHILE b <= 10 DO declare d int;set d = b + 2;if d > 9 then select *, 'this is t1 values in while' from t1; leave my_loop;elsif b > 5 then select *, 'this is t2 values in while' from t2; endif; set b = b + 1; ENDWHILE; IF err = 0 THEN SELECT a,b , 'this is procedure values'; select *, 'this is t1 values' from t1;ENDIF;COMMIT; end;
CREATE PROCEDURE
> call test();
  a  |  b   |     ?column?
-----+------+--------------------
   3 |    4 | this is t1 values
  10 | NULL | this is t1 values
(2 rows)
  a | b | c |          ?column?
----+---+---+-----------------------------
  1 | 2 | 3 | this is t2 values in while
  4 | 5 | 6 | this is t2 values in while
(2 rows)
  a | b | c |          ?column?
----+---+---+-----------------------------
  1 | 2 | 3 | this is t2 values in while
  4 | 5 | 6 | this is t2 values in while
(2 rows)
  a  |  b   |          ?column?
-----+------+-----------------------------
   3 |    4 | this is t1 values in while
  10 | NULL | this is t1 values in while
(2 rows)
  a  | b |         ?column?
-----+---+---------------------------
  10 | 8 | this is procedure values
(1 row)
  a  |  b   |     ?column?
-----+------+--------------------
   3 |    4 | this is t1 values
  10 | NULL | this is t1 values
(2 rows)
> drop procedure test;
DROP PROCEDURE
> create procedure p5() begin declare d int; set d = 10; insert into t1(a) values (d); if row_count() > 1 then select * from t1; endif; end;
CREATE PROCEDURE
> call p5();
--
(0 rows)
> drop procedure p5;
DROP PROCEDURE
> create procedure test8() begin declare a int; declare d int default 0; set a =1; LABEL my_loop: while a<3 do select d; set a=a+1;LEAVE my_loop;endwhile my_loop;end;
CREATE PROCEDURE
> call test8();
  d
-----
  0
(1 row)
> drop procedure test8;
DROP PROCEDURE
> create procedure test4() begin declare a int;declare b int default 0;set a = 10; declare continue HANDLER FOR NOT FOUND set b = 9; WHILE b <= 10 DO declare d int;set d = b + 2;if d > 9 then select * from t1; elsif b > 5 then select * from t2; elsif b <= 4 then select * from t3; endif;set b = b + 1; ENDWHILE; end;
CREATE PROCEDURE
> call test4();
  a  |  b
-----+-------
   4 |    4
  10 | NULL
  10 |    0
  10 | NULL
(4 rows)
> drop procedure test4;
DROP PROCEDURE
> create procedure test6() begin declare a int;declare b int default 0;set a = 10; declare continue HANDLER FOR NOT FOUND set b = 9; WHILE b <= 10 DO declare d int;set d = b + 2;if d > 9 then select * from t1; elsif b > 5 then select * from t2; elsif b <= 4 then select * from t3; endif;set b = b + 1; ENDWHILE; end;
CREATE PROCEDURE
> call test6();
  a  |  b
-----+-------
   4 |    4
  10 | NULL
  10 |    0
  10 | NULL
(4 rows)
> drop procedure test6;
DROP PROCEDURE
> create procedure test7() begin declare a int;declare b int default 0;set a = 10; declare continue HANDLER FOR SQLEXCEPTION set b = 9; WHILE b <= 10 DO declare d int;set d = b + 2;if d > 9 then select * from t1; elsif b > 5 then select * from t2; elsif b <= 4 then select * from t3; endif;set b = b + 1; ENDWHILE; end;
CREATE PROCEDURE
> call test7();
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
  a  |  b
-----+-------
   4 |    4
  10 | NULL
  10 |    0
  10 | NULL
(4 rows)
  a  |  b
-----+-------
   4 |    4
  10 | NULL
  10 |    0
  10 | NULL
(4 rows)
  a  |  b
-----+-------
   4 |    4
  10 | NULL
  10 |    0
  10 | NULL
(4 rows)
> drop procedure test7;
DROP PROCEDURE
> create procedure p1() begin declare a int;declare b int; set b = 10; select b; end;
CREATE PROCEDURE
> call p1();
  b
------
  10
(1 row)
> drop procedure p1;
DROP PROCEDURE
> create procedure test91() begin declare a int default 0;declare b int default 0; WHILE b <= 5 do declare d int;set d = b + 2; select a,b,d from t1; set b = b +1;  ENDWHILE; end;
CREATE PROCEDURE
> call test91();
  a  |  b   | d
-----+------+----
   4 |    4 | 2
  10 | NULL | 2
  10 |    0 | 2
  10 | NULL | 2
(4 rows)
  a  |  b   | d
-----+------+----
   4 |    4 | 3
  10 | NULL | 3
  10 |    0 | 3
  10 | NULL | 3
(4 rows)
  a  |  b   | d
-----+------+----
   4 |    4 | 4
  10 | NULL | 4
  10 |    0 | 4
  10 | NULL | 4
(4 rows)
  a  |  b   | d
-----+------+----
   4 |    4 | 5
  10 | NULL | 5
  10 |    0 | 5
  10 | NULL | 5
(4 rows)
  a  |  b   | d
-----+------+----
   4 |    4 | 6
  10 | NULL | 6
  10 |    0 | 6
  10 | NULL | 6
(4 rows)
  a  |  b   | d
-----+------+----
   4 |    4 | 7
  10 | NULL | 7
  10 |    0 | 7
  10 | NULL | 7
(4 rows)
> drop procedure test91;
DROP PROCEDURE
> create procedure test92() begin declare a int default 0;declare d int default 0; set d = 10; select a,b,d from t1; end;
CREATE PROCEDURE
> call test92();
  a  |  b   | d
-----+------+-----
   4 |    4 | 10
  10 | NULL | 10
  10 |    0 | 10
  10 | NULL | 10
(4 rows)
> drop procedure test92;
DROP PROCEDURE
> create procedure test30() begin declare a int default 0;declare b int default 0;set a = 10;WHILE b <= 10 DO declare d int;set d = b + 2;if d > 9 then select a,b,d from t1; elsif b > 5 then select a,b,c,d from t2; endif;set b = b + 1; ENDWHILE; end;
CREATE PROCEDURE
> call test30();
  a | b | c | d
----+---+---+----
  1 | 2 | 3 | 8
  4 | 5 | 6 | 8
(2 rows)
  a | b | c | d
----+---+---+----
  1 | 2 | 3 | 9
  4 | 5 | 6 | 9
(2 rows)
  a  |  b   | d
-----+------+-----
   4 |    4 | 10
  10 | NULL | 10
  10 |    0 | 10
  10 | NULL | 10
(4 rows)
  a  |  b   | d
-----+------+-----
   4 |    4 | 11
  10 | NULL | 11
  10 |    0 | 11
  10 | NULL | 11
(4 rows)
  a  |  b   | d
-----+------+-----
   4 |    4 | 12
  10 | NULL | 12
  10 |    0 | 12
  10 | NULL | 12
(4 rows)
> drop procedure test30;
DROP PROCEDURE
> create procedure test31() begin declare a int default 0;declare b int default 0;set a = 10;WHILE b <= 10 DO declare d int;set d = b + 2;if d > 9 then select a,b,d from t1; elsif b > 5 then select a,b,c,d from t2; endif;set b = b + 1; ENDWHILE; end;
CREATE PROCEDURE
> call test31();
  a | b | c | d
----+---+---+----
  1 | 2 | 3 | 8
  4 | 5 | 6 | 8
(2 rows)
  a | b | c | d
----+---+---+----
  1 | 2 | 3 | 9
  4 | 5 | 6 | 9
(2 rows)
  a  |  b   | d
-----+------+-----
   4 |    4 | 10
  10 | NULL | 10
  10 |    0 | 10
  10 | NULL | 10
(4 rows)
  a  |  b   | d
-----+------+-----
   4 |    4 | 11
  10 | NULL | 11
  10 |    0 | 11
  10 | NULL | 11
(4 rows)
  a  |  b   | d
-----+------+-----
   4 |    4 | 12
  10 | NULL | 12
  10 |    0 | 12
  10 | NULL | 12
(4 rows)
> drop procedure test31;
DROP PROCEDURE
> CREATE PROCEDURE test_variables() BEGIN DECLARE var1 INT default 0;DECLARE var2 VARCHAR(20); SET var1 = 10; SET var2 = 'Hello'; SELECT var1 + 5, CONCAT(var2, ' World'); end;
CREATE PROCEDURE
> call test_variables();
  ?column? |   concat
-----------+--------------
        15 | Hello World
(1 row)
> drop procedure test_variables;
DROP PROCEDURE
> create procedure test_cursor() label test: begin declare a int; DECLARE done INT DEFAULT 0; DECLARE cur CURSOR FOR SELECT a FROM t1; declare continue HANDLER FOR NOT FOUND BEGIN SET done = 1; select 'result get all' as print; ENDHANDLER; OPEN cur; label read_loop: while done = 0 DO declare b int; FETCH cur INTO b; SELECT b; ENDWHILE read_loop; CLOSE cur; end ;
CREATE PROCEDURE
> call test_cursor();
  b
-----
  4
(1 row)
  b
------
  10
(1 row)
  b
------
  10
(1 row)
  b
------
  10
(1 row)
      print
------------------
  result get all
(1 row)
   b
--------
  NULL
(1 row)
> drop procedure test_cursor;
DROP PROCEDURE
> CREATE TABLE employees(id SERIAL PRIMARY KEY, name VARCHAR(100),age INT, salary decimal(10,2));
CREATE TABLE
> INSERT INTO employees (name, age, salary) VALUES ('test1', 1, 2.2);
INSERT 1
> INSERT INTO employees (name, age, salary) VALUES ('test2', 2, 2.2);
INSERT 1
> INSERT INTO employees (name, age, salary) VALUES ('test3', 3, 2.2);
INSERT 1
> CREATE PROCEDURE add1(emp_age INT, age int) BEGIN declare var_done int; declare var_age int; set var_age = 1; DECLARE cur CURSOR FOR SELECT age FROM employees; DECLARE CONTINUE HANDLER FOR NOT FOUND SET var_done = 1; OPEN cur; LABEL my_loop: WHILE var_age > 0 DO FETCH cur INTO var_age; IF var_done = 1 THEN LEAVE my_loop; ENDIF; select var_age; ENDWHILE; CLOSE cur; END;
CREATE PROCEDURE
> call add1(1,2);
  var_age
-----------
        1
(1 row)
  var_age
-----------
        2
(1 row)
  var_age
-----------
        3
(1 row)
> drop procedure add1;
DROP PROCEDURE
> CREATE PROCEDURE add2(emp_age INT, age int) BEGIN declare var_done int; declare var_age int; set var_age = 1; DECLARE cur CURSOR FOR SELECT age FROM employees; DECLARE CONTINUE HANDLER FOR NOT FOUND SET var_done = 1; OPEN cur; LABEL my_loop: WHILE var_age > 0 DO FETCH cur INTO var_age; IF var_done = 1 THEN LEAVE my_loop; ENDIF; select var_age; ENDWHILE; CLOSE cur; END;
CREATE PROCEDURE
> call add2(1,2);
  var_age
-----------
        1
(1 row)
  var_age
-----------
        2
(1 row)
  var_age
-----------
        3
(1 row)
> drop procedure add2;
DROP PROCEDURE
> CREATE PROCEDURE add3(emp_age INT, age int) BEGIN declare var_done int; declare var_age int; set var_age = 1; DECLARE cur CURSOR FOR SELECT age FROM employees; DECLARE CONTINUE HANDLER FOR NOT FOUND SET var_done = 1; OPEN cur; LABEL my_loop: WHILE var_age > 0 DO FETCH cur INTO var_age; IF var_done = 1 THEN LEAVE my_loop; ENDIF; select var_age; ENDWHILE; CLOSE cur; END;
CREATE PROCEDURE
> call add3(1,2);
  var_age
-----------
        1
(1 row)
  var_age
-----------
        2
(1 row)
  var_age
-----------
        3
(1 row)
> drop procedure add3;
DROP PROCEDURE
> CREATE PROCEDURE add4(emp_age INT, age int) BEGIN declare var_done int; declare var_age int; set var_age = 1; declare var_name int; DECLARE cur CURSOR FOR SELECT age FROM employees; DECLARE CONTINUE HANDLER FOR NOT FOUND SET var_done = 1; OPEN cur; LABEL my_loop: WHILE var_age > 0 DO FETCH cur INTO var_age, var_name; IF var_done = 1 THEN LEAVE my_loop; ENDIF; select var_age; ENDWHILE my_loop; CLOSE cur; INSERT INTO employees (name, age, salary) VALUES ('qiliang111', 111, 3.2); END;
CREATE PROCEDURE
> call add4(1,2);
ERROR: the number of columns fetched does not match the number of variables, cols: 1, variables:2
SQLSTATE: 24000
> drop procedure add4;
DROP PROCEDURE
> CREATE PROCEDURE add5(emp_age INT, age int) BEGIN declare var_done int; declare var_age int; set var_age = 1; declare var_name int; DECLARE cur CURSOR FOR SELECT age FROM employees; DECLARE CONTINUE HANDLER FOR NOT FOUND SET var_done = 1; OPEN cur; LABEL my_loop: WHILE var_age > 0 DO FETCH cur INTO var_age; IF var_done = 1 THEN LEAVE my_loop; ENDIF; select var_age; ENDWHILE my_loop; CLOSE cur; INSERT INTO employees (name, age, salary) VALUES ('qiliang111', 111, 3.2); END;
CREATE PROCEDURE
> call add5(1,2);
  var_age
-----------
        1
(1 row)
  var_age
-----------
        2
(1 row)
  var_age
-----------
        3
(1 row)
> drop procedure add5;
DROP PROCEDURE
> create procedure add6() label test:begin  declare a int default 0; declare b int default 0; declare err int default 0; declare exit HANDLER FOR NOT FOUND,SQLEXCEPTION BEGIN SET err = -1; SELECT a,b; ROLLBACK; ENDHANDLER; START TRANSACTION; set a = 10; select a, b from t1; update t1 set a =  a + 1 where b > 0; insert into t1 values (a, b); label my_loop: WHILE b <= 10 DO declare d int; set d = b + 2; if d > 9 then select * from t1; leave my_loop; elsif b > 5 then select * from t2; endif; set b = b + 1; ENDWHILE; IF err = 0 THEN SELECT a,b; COMMIT; ENDIF; end;
CREATE PROCEDURE
> call add6();
  a  |  b
-----+-------
   4 |    4
  10 | NULL
  10 |    0
  10 | NULL
(4 rows)
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
  a | b | c
----+---+----
  1 | 2 | 3
  4 | 5 | 6
(2 rows)
  a  |  b
-----+-------
   4 |    4
  10 | NULL
  10 |    0
  10 | NULL
(4 rows)
  a  | b
-----+----
  10 | 8
(1 row)
> drop procedure add6;
DROP PROCEDURE
> drop table employees;
DROP TABLE
> create procedure p1() begin declare exit HANDLER FOR NOT FOUND,SQLEXCEPTION BEGIN SET err = -1; SELECT err,out_ol_supply_w_ids, out_i_ids, out_ol_quantities, out_item_names, out_supply_quantities, out_brand_generic, out_prices, out_amounts,out_total_amount,out_c_credit,out_c_discount,out_c_last, out_o_id,out_d_tax,out_o_entry_d,out_w_tax; ROLLBACK; ENDHANDLER; end;
ERROR: variable "err" does not exist
SQLSTATE: 42703
> drop procedure p1;
ERROR: procedure "p1" does not exist
SQLSTATE: 42704
> CREATE PROCEDURE p3(a INT4) BEGIN DECLARE b INT4; declare c int4;declare c1 cursor for select a from t1 ; open c1;delete from t1 where a = 1;fetch c1 into b;fetch c1 into c;close c1 ;select b;select c;END;
CREATE PROCEDURE
> call p3(1);
  b
-----
  5
(1 row)
  c
------
  10
(1 row)
> drop procedure p3;
DROP PROCEDURE
> drop table if exists bmsql_item;
DROP TABLE
> create table bmsql_item (
i_id integer not null,
i_name varchar(24),
i_price decimal(5,2),
i_data varchar(50),
i_im_id integer,
primary key (i_id)
);
CREATE TABLE
> insert into bmsql_item values(23793, 'EYgGREs95keggHoKSWZYp', 96.63, 'abmFWK6MwPyDUSWgp0furfZurJP', 4567);
INSERT 1
> DROP PROCEDURE IF EXISTS bmsql_proc_new_order;
DROP PROCEDURE
> CREATE PROCEDURE bmsql_proc_new_order(
	in_w_id int,
	in_d_id int,
	in_c_id int,
	in_o_ol_cnt int,
	in_o_all_local int,
	in_ol_i_id_array varchar(512),
	in_ol_supply_w_id_array varchar(512),
	in_ol_quantity varchar(512)) 
BEGIN 
	declare var_i_price decimal(5,2) default NULL; 
	declare var_i_name varchar(24) default NULL; 
	declare var_ol_number int default 1; 
	START TRANSACTION; 
	WHILE var_ol_number <= in_o_ol_cnt DO 
		SELECT i_price, i_name AS bg INTO var_i_price, var_i_name FROM bmsql_item WHERE i_id = 23793;
		SET var_ol_number= var_ol_number+1;
	ENDWHILE;
	COMMIT;
END ;
CREATE PROCEDURE
> call bmsql_proc_new_order(1, 3, 236, 2, 1, '23793,33231,34317,42513,42513,49887,50697,58887,66991,67565,70673,87404,96719', '1,1,1,1,1,1,1,1,1,1,1,1,1', '7,8,4,8,7,2,7,6,5,2,8,4,1');
CALL PROCEDURE
> drop procedure bmsql_proc_new_order;
DROP PROCEDURE
> drop table bmsql_item;
DROP TABLE
> drop table if exists bmsql_stock;
DROP TABLE
> create table bmsql_stock (
s_i_id integer not null,
s_w_id integer not null,
s_quantity integer,
s_ytd integer,
s_order_cnt integer,
s_remote_cnt integer,
s_data varchar(50),
s_dist_01 char(24),
s_dist_02 char(24),
s_dist_03 char(24),
s_dist_04 char(24),
s_dist_05 char(24),
s_dist_06 char(24),
s_dist_07 char(24),
s_dist_08 char(24),
s_dist_09 char(24),
s_dist_10 char(24),
primary key (s_w_id, s_i_id),
index bmsql_stock_idx1(s_i_id)
);
CREATE TABLE
> insert into bmsql_stock(s_i_id, s_w_id, s_order_cnt) values(23793, 1, 0);
INSERT 1
> CREATE PROCEDURE bmsql_proc_new_order() 
BEGIN 
	declare var_s_quantity smallint default NULL; 
	declare var_ol_number int default 1; 
	WHILE var_ol_number <= 2 DO 
		UPDATE bmsql_stock SET s_order_cnt = s_order_cnt + 1 WHERE s_i_id = 23793 AND s_w_id = 1 RETURNING s_order_cnt;
		SET var_ol_number= var_ol_number+1;
	ENDWHILE;
END ;
CREATE PROCEDURE
> call bmsql_proc_new_order();
  s_order_cnt
---------------
            1
(1 row)
  s_order_cnt
---------------
            2
(1 row)
> drop procedure bmsql_proc_new_order;
DROP PROCEDURE
> drop table bmsql_stock;
DROP TABLE
> create table test_order (
no_w_id integer not null,
no_d_id integer not null,
no_o_id integer not null
);
CREATE TABLE
> DROP PROCEDURE IF EXISTS bmsql_proc_del;
DROP PROCEDURE
> CREATE PROCEDURE bmsql_proc_del() 
BEGIN 
	declare i int default 1; 
	declare del_o_id int; 
	delete from test_order where 1=1; 
	WHILE i < 3 DO 
		INSERT INTO test_order(no_o_id, no_d_id, no_w_id) VALUES (i, 1, 1) RETURNING no_o_id;
		DELETE FROM test_order WHERE no_w_id = 1 AND no_d_id = 1 AND no_o_id = i RETURNING no_o_id into del_o_id;
		select del_o_id;
		set i = i+1;
	ENDWHILE;
END ;
CREATE PROCEDURE
> call bmsql_proc_del();
  no_o_id
-----------
        1
(1 row)
  del_o_id
------------
         1
(1 row)
  no_o_id
-----------
        2
(1 row)
  del_o_id
------------
         2
(1 row)
> drop procedure bmsql_proc_del;
DROP PROCEDURE
> drop table test_order;
DROP TABLE
> drop database procedure_db cascade;
DROP DATABASE
> DROP DATABASE IF EXISTS db cascade;
DROP DATABASE
> create PROCEDURE prc_declare() begin declare counts1 string;declare counts2 int default 0; declare counts3 int default 0; set counts1 ='10a'; set counts2 ='123'; set counts3 ='10'; SELECT counts1, (counts2+counts3); end;
CREATE PROCEDURE
> CALL prc_declare();
  counts1 | ?column?
----------+-----------
  10a     |      133
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare() begin SELECT counts1; end;
ERROR: column "counts1" does not exist
SQLSTATE: 42703
> create PROCEDURE prc_declare() begin SELECT '0'; end;
CREATE PROCEDURE
> CALL prc_declare();
  ?column?
------------
  0
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare() begin set counts1 ='10a'; set counts2 ='tesr'; set counts3 ='10'; SELECT counts1 ; SELECT counts2 ; SELECT counts3 ; end;
ERROR: variable "counts1" does not exist
SQLSTATE: 42703
> create PROCEDURE prc_declare() begin set counts1 ='10a'; set counts2 ='tesr'; set counts3 ='10'; SELECT counts1, (counts2+counts3);end;
ERROR: variable "counts1" does not exist
SQLSTATE: 42703
> create PROCEDURE prc_declare() begin set counts1 ='10a';set counts1 ='10a';set counts3 ='10';SELECT 1; end;
ERROR: variable "counts1" does not exist
SQLSTATE: 42703
> create PROCEDURE prc_declare() begin declare counts1 int;declare counts2 int;declare counts3 int; SELECT counts1*(counts2+counts3); SELECT '10', 999, 'abc'; SELECT counts1*(counts2+counts3-1)-counts1%counts3 - counts2*1+1; end;
CREATE PROCEDURE
> CALL prc_declare();
  ?column?
------------
      NULL
(1 row)
  ?column? | ?column? | ?column?
-----------+----------+-----------
  10       |      999 | abc
(1 row)
  ?column?
------------
      NULL
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare(a INT) begin declare counts int; set counts = 1; set a =10; set a =11; SELECT a+counts ;end;
CREATE PROCEDURE
> CALL prc_declare(1);
  ?column?
------------
        12
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare(a INT) begin declare counts int; set counts = 1; SELECT a+counts ; end;
CREATE PROCEDURE
> CALL prc_declare(1);
  ?column?
------------
         2
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare(a INT) begin declare counts int;declare a int;set counts = 1; SELECT a+counts; end;
CREATE PROCEDURE
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare() begin declare a1 INT default 9223372036854775807; SELECT a1 ;end;
CREATE PROCEDURE
> CALL prc_declare();
ERROR: integer out of range for type int4 (column "a1")
SQLSTATE: 22003
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare() begin declare a1 timestamp default 9223372036854775807; SELECT a1 ;end;
ERROR: expected DEFAULT expression to have type timestamp, but '9223372036854775807' has type int
> create PROCEDURE prc_declare() begin declare a1 timestamp default '2020-01-02 10:00:00'; SELECT a1 ;end;
CREATE PROCEDURE
> CALL prc_declare();
             a1
-----------------------------
  2020-01-02 10:00:00+00:00
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare() begin declare a1 timestamp(9) default '2020-01-02 10:00:00.123456789'; SELECT a1 ;end;
CREATE PROCEDURE
> CALL prc_declare();
                  a1
---------------------------------------
  2020-01-02 10:00:00.123456789+00:00
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare() begin declare a1 timestamp(3) default '2020-01-02 10:00:00.123456789'; SELECT a1 ;end;
CREATE PROCEDURE
> CALL prc_declare();
               a1
---------------------------------
  2020-01-02 10:00:00.123+00:00
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare(b timestamp) begin declare a1 TIMESTAMP default now()+b; SELECT a1 ;end;
ERROR: variable sub-expressions are not allowed in DEFAULT
SQLSTATE: 42601
> create PROCEDURE prc_declare() begin declare a1 INT default 9223372036854775808; SELECT a1 ;end;
ERROR: numeric constant out of int64 range
SQLSTATE: 22003
> create PROCEDURE prc_declare() begin declare a1 DECIMAL(1,1)  default 3.21; SELECT a1 ;end;
CREATE PROCEDURE
> call prc_declare();
ERROR: type DECIMAL(1,1) (column "a1"): value with precision 1, scale 1 must round to an absolute value less than 1
SQLSTATE: 22003
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> create PROCEDURE prc_declare() begin declare a1 INT default null; SELECT a1 ;end;
CREATE PROCEDURE
> CALL prc_declare();
   a1
--------
  NULL
(1 row)
> DROP PROCEDURE prc_declare;
DROP PROCEDURE
> DROP PROCEDURE IF EXISTS fun_LOOP_TEST2;
DROP PROCEDURE
> DROP TABLE IF EXISTS prc_tab;
DROP TABLE
> CREATE TABLE prc_tab(loop_test2 decimal(10,3));
CREATE TABLE
> create PROCEDURE LOOP_TEST2(m INT) BEGIN DECLARE n NUMERIC default 1; DECLARE l decimal(10,3) default 1.0; WHILE l < 10 DO set n = n+1;  select n; set l = m*n; select l;  ENDWHILE;  INSERT INTO prc_tab VALUES(l); END;
CREATE PROCEDURE
> CALL LOOP_TEST2(1);
  n
-----
  2
(1 row)
    l
---------
  2.000
(1 row)
  n
-----
  3
(1 row)
    l
---------
  3.000
(1 row)
  n
-----
  4
(1 row)
    l
---------
  4.000
(1 row)
  n
-----
  5
(1 row)
    l
---------
  5.000
(1 row)
  n
-----
  6
(1 row)
    l
---------
  6.000
(1 row)
  n
-----
  7
(1 row)
    l
---------
  7.000
(1 row)
  n
-----
  8
(1 row)
    l
---------
  8.000
(1 row)
  n
-----
  9
(1 row)
    l
---------
  9.000
(1 row)
  n
------
  10
(1 row)
    l
----------
  10.000
(1 row)
> SELECT * FROM prc_tab;
  loop_test2
--------------
      10.000
(1 row)
> CALL LOOP_TEST2(100);
  n
-----
  2
(1 row)
     l
-----------
  200.000
(1 row)
> SELECT * FROM prc_tab;
  loop_test2
--------------
      10.000
     200.000
(2 rows)
> DROP TABLE prc_tab;
ERROR: cannot drop relation "prc_tab" because procedure "defaultdb.public.loop_test2" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.loop_test2 instead.
> DROP PROCEDURE LOOP_TEST2;
DROP PROCEDURE
> DROP TABLE prc_tab;
DROP TABLE
> CREATE TABLE test (a INT,b int);
CREATE TABLE
> INSERT INTO test values(1,1),(1,2),(1,3),(1,4),(1,5);
INSERT 5
> CREATE PROCEDURE if_test1(c INT) begin IF c is null THEN INSERT INTO test VALUES (0,0); ELSIF c < 5 THEN INSERT INTO test VALUES(1,c); ELSE INSERT INTO test VALUES(2,c); ENDIF; END;
CREATE PROCEDURE
> call if_test1(null);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
(6 rows)
> call if_test1(0);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
  1 | 0
(7 rows)
> call if_test1(1);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
  1 | 0
  1 | 1
(8 rows)
> call if_test1(5);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
  1 | 0
  1 | 1
  2 | 5
(9 rows)
> call if_test1(6);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
  1 | 0
  1 | 1
  2 | 5
  2 | 6
(10 rows)
> DROP TABLE test;
ERROR: cannot drop relation "test" because procedure "defaultdb.public.if_test1" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.if_test1 instead.
> DROP PROCEDURE if_test1;
DROP PROCEDURE
> DROP TABLE test;
DROP TABLE
> DROP TABLE IF EXISTS test;
DROP TABLE
> DROP PROCEDURE IF EXISTS if_test1;
DROP PROCEDURE
> CREATE TABLE test (a INT,b int);
CREATE TABLE
> INSERT INTO test values(1,1),(1,2),(1,3),(1,4),(1,5);
INSERT 5
> CREATE PROCEDURE if_test1(c INT) BEGIN IF c is null THEN INSERT INTO test VALUES (0,0); ELSIF c = 3 THEN INSERT INTO test VALUES(1,c); ELSIF c = 3 THEN INSERT INTO test VALUES(1,c); ENDIF; END;
CREATE PROCEDURE
> call if_test1(null);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
(6 rows)
> call if_test1(0);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
(6 rows)
> call if_test1(1);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
(6 rows)
> call if_test1(3);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
  1 | 3
(7 rows)
> call if_test1(5);
CALL PROCEDURE
> SELECT * from test;
  a | b
----+----
  1 | 1
  1 | 2
  1 | 3
  1 | 4
  1 | 5
  0 | 0
  1 | 3
(7 rows)
> DROP TABLE test;
ERROR: cannot drop relation "test" because procedure "defaultdb.public.if_test1" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.if_test1 instead.
> DROP PROCEDURE if_test1;
DROP PROCEDURE
> DROP TABLE test;
DROP TABLE
> DROP TABLE IF EXISTS test;
DROP TABLE
> DROP PROCEDURE IF EXISTS loop_test1;
DROP PROCEDURE
> CREATE TABLE test (a INT);
CREATE TABLE
> CREATE PROCEDURE loop_test1() BEGIN DECLARE c INT default 1; label my_loop: WHILE 1 DO INSERT INTO test VALUES(c); IF c>5 THEN leave my_loop; ENDIF; set c=c+1; ENDWHILE; END;
CREATE PROCEDURE
> call loop_test1();
CALL PROCEDURE
> select * from test;
  a
-----
  1
  2
  3
  4
  5
  6
(6 rows)
> DROP TABLE test;
ERROR: cannot drop relation "test" because procedure "defaultdb.public.loop_test1" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.loop_test1 instead.
> DROP PROCEDURE loop_test1;
DROP PROCEDURE
> DROP TABLE test;
DROP TABLE
> create table test1 (id int,a int);
CREATE TABLE
> CREATE procedure pro_12 (x int8, y int8) BEGIN DECLARE re int8;  set re=x+y;   insert into test1(id,a) values (1,re); END;
CREATE PROCEDURE
> call pro_12(6,4);
CALL PROCEDURE
> select * from test1;
  id | a
-----+-----
   1 | 10
(1 row)
> drop table if exists test1;
ERROR: cannot drop relation "test1" because procedure "defaultdb.public.pro_12" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.pro_12 instead.
> drop procedure if exists pro_12;
DROP PROCEDURE
> drop table if exists test1;
DROP TABLE
> create table test1 (id int,a int);
CREATE TABLE
> CREATE procedure pro_13 (x int8, y int8) BEGIN DECLARE re int8;  insert into test1(id,a) values (1,x+y); END;
CREATE PROCEDURE
> call pro_13(6,4);
CALL PROCEDURE
> select * from test1;
  id | a
-----+-----
   1 | 10
(1 row)
> drop table if exists test1;
ERROR: cannot drop relation "test1" because procedure "defaultdb.public.pro_13" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.pro_13 instead.
> drop procedure if exists pro_13;
DROP PROCEDURE
> drop table if exists test1;
DROP TABLE
> DROP TABLE IF EXISTS CP_TEST;
DROP TABLE
> CREATE TABLE cp_test (a int, b text);
CREATE TABLE
> DROP PROCEDURE IF EXISTS  ptest1;
DROP PROCEDURE
> CREATE PROCEDURE ptest1(x text) BEGIN INSERT INTO cp_test VALUES (1, x); END;
CREATE PROCEDURE
> SELECT ptest1('x');
ERROR: unknown function: ptest1()
SQLSTATE: 42883
> CALL ptest1('a');
CALL PROCEDURE
> CALL ptest1('xy' || 'zzy');
CALL PROCEDURE
> CALL ptest1(substring(random()::numeric(20,15)::text, 1, 1));
CALL PROCEDURE
> SELECT * FROM cp_test ORDER BY b ;
  a |   b
----+--------
  1 | 0
  1 | a
  1 | xyzzy
(3 rows)
> DROP TABLE IF EXISTS CP_TEST;
ERROR: cannot drop relation "cp_test" because procedure "defaultdb.public.ptest1" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.ptest1 instead.
> DROP PROCEDURE IF EXISTS  ptest1;
DROP PROCEDURE
> DROP TABLE IF EXISTS CP_TEST;
DROP TABLE
> drop table if exists test;
DROP TABLE
> create table test (old text, new text, mod_time timestamp);
CREATE TABLE
> insert into test values ('old', 'new', '20201013');
INSERT 1
> select old,new from test ;
  old | new
------+------
  old | new
(1 row)
> drop procedure if exists upreturn2;
DROP PROCEDURE
> create procedure upreturn2(a int,X text)  begin update test set new = 'bill', old = new, mod_time = '20250513' returning new into X; select X; end;
CREATE PROCEDURE
> CALL upreturn2(1,'text');
   x
--------
  bill
(1 row)
> select * from test;
  old | new  |         mod_time
------+------+----------------------------
  new | bill | 2025-05-13 00:00:00+00:00
(1 row)
> drop procedure if exists upreturn2;
DROP PROCEDURE
> drop table if exists test;
DROP TABLE
> drop table if exists test;
DROP TABLE
> create table test (old text, new text, mod_time timestamp);
CREATE TABLE
> insert into test values ('old', 'new', '20201013');
INSERT 1
> select old,new from test ;
  old | new
------+------
  old | new
(1 row)
> drop procedure if exists delreturn2;
DROP PROCEDURE
> create procedure delreturn2(X TEXT) begin delete from test returning new into X; select X; end;
CREATE PROCEDURE
> select * from test;
  old | new |         mod_time
------+-----+----------------------------
  old | new | 2020-10-13 00:00:00+00:00
(1 row)
> call delreturn2('NEW');
   x
-------
  new
(1 row)
> drop procedure if exists delreturn2;
DROP PROCEDURE
> drop table if exists test;
DROP TABLE
> drop table if exists test;
DROP TABLE
> create table test (old text, new text, mod_time timestamp);
CREATE TABLE
> insert into test values ('old', 'new', '20201013');
INSERT 1
> select old,new from test ;
  old | new
------+------
  old | new
(1 row)
> drop procedure if exists insreturn2;
DROP PROCEDURE
> create procedure insreturn2(X text) begin insert into test values('insert','insert','20201010') returning new into X; select X; end;
CREATE PROCEDURE
> call insreturn2('insert');
    x
----------
  insert
(1 row)
> drop procedure if exists insreturn2;
DROP PROCEDURE
> select old,new from test ;
   old   |  new
---------+---------
  old    | new
  insert | insert
(2 rows)
> drop table if exists test;
DROP TABLE
> drop table if exists test;
DROP TABLE
> create table test(id int);
CREATE TABLE
> insert into test select generate_series(1,20);
INSERT 20
> CREATE procedure fun_affect_rows() 
begin 
	declare v_count1 int; 
	declare v_count2 int; 
	declare v_count3 int; 
	insert into test values(99),(98); 
	set v_count1 = ROW_COUNT(); 
	select v_count1; 
	delete from test where id < 15; 
	set v_count2 = ROW_COUNT(); 
	select v_count2; 
	update test set id = 100 where id >90; 
	set v_count3 = ROW_COUNT(); 
	select v_count3; 
end ;
CREATE PROCEDURE
> call fun_affect_rows();
  v_count1
------------
         2
(1 row)
  v_count2
------------
        14
(1 row)
  v_count3
------------
         2
(1 row)
> drop procedure fun_affect_rows;
DROP PROCEDURE
> drop table if exists test;
DROP TABLE
> drop table if  exists test1;
DROP TABLE
> create table test1(a int);
CREATE TABLE
> drop PROCEDURE if exists transaction_test1;
DROP PROCEDURE
> CREATE PROCEDURE transaction_test1()
BEGIN    
	declare i INT default 0;
	
	while i < 9 do
		START TRANSACTION;
		INSERT INTO test1 (a) VALUES (i);
		IF i % 2 = 0 THEN
			COMMIT;
		ELSE
			ROLLBACK;
		ENDIF;
		set i = i + 1;
	ENDwhile; 
END ;
CREATE PROCEDURE
> CALL transaction_test1();
CALL PROCEDURE
> select * from test1;--expected 0 2 4 6 8
  a
-----
  0
  2
  4
  6
  8
(5 rows)
> drop table if  exists test1;
ERROR: cannot drop relation "test1" because procedure "defaultdb.public.transaction_test1" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.transaction_test1 instead.
> drop PROCEDURE if exists transaction_test1;
DROP PROCEDURE
> drop table if  exists test1;
DROP TABLE
> create table test1(a int);
CREATE TABLE
> drop PROCEDURE if exists transaction_test1;
DROP PROCEDURE
> CREATE PROCEDURE transaction_test1() 
BEGIN     
	declare i INT default 0;
	
	while i < 9 do
		START TRANSACTION;
		INSERT INTO test1 (a) VALUES (i);
		IF i % 2 = 0 THEN
			ROLLBACK;
		ELSE
			commit;
		ENDIF; 
		set i = i + 1;
	ENDWHILE; 
END ;
CREATE PROCEDURE
> CALL transaction_test1();
CALL PROCEDURE
> select * from test1;--expected 1 3 5 7 9
  a
-----
  1
  3
  5
  7
(4 rows)
> drop PROCEDURE if exists transaction_test1;
DROP PROCEDURE
> DROP DATABASE IF EXISTS db cascade;
DROP DATABASE
> DROP DATABASE IF EXISTS db1 cascade;
DROP DATABASE
> create database db1;
CREATE DATABASE
> create table db1.t1(a int);
CREATE TABLE
> create table db1.t2(b int);
CREATE TABLE
> insert into db1.t1 values(111);
INSERT 1
> insert into db1.t2 values(222);
INSERT 1
> create procedure db1.p1() begin select *from db1.t1,db1.t2; end;
CREATE PROCEDURE
> call db1.p1();
   a  |  b
------+------
  111 | 222
(1 row)
> DROP DATABASE IF EXISTS db1 cascade;
DROP DATABASE
> drop PROCEDURE if exists duplicate_para_test1;
DROP PROCEDURE
> create procedure duplicate_para_test1(a int, a string) begin select a; select a!=0; end;
ERROR: parameter name "a" used more than once
SQLSTATE: 42P13
> create procedure duplicate_para_test1(a int) begin declare b int; declare c string; declare b string; end;
ERROR: duplicate variable name: "b"
SQLSTATE: 42701
> drop PROCEDURE if exists overwrite_para_test1;
DROP PROCEDURE
> create procedure overwrite_para_test1(a int) begin select a; select a!=0; declare b int; set b=12; declare a string; set a ='zx'; select a; select a!='zx'; end;
CREATE PROCEDURE
> call overwrite_para_test1(123);
   a
-------
  123
(1 row)
  ?column?
------------
    true
(1 row)
  a
------
  zx
(1 row)
  ?column?
------------
   false
(1 row)
> drop PROCEDURE if exists overwrite_para_test1;
DROP PROCEDURE
> create database test_db;
CREATE DATABASE
> use test_db;
SET
> create table t1(a int2);
CREATE TABLE
> insert into t1 values(1);
INSERT 1
> DROP PROCEDURE IF EXISTS test_redeclare;
DROP PROCEDURE
> CREATE PROCEDURE test_redeclare(test1 STRING) BEGIN DECLARE test1 int2; SELECT a INTO test1 FROM test_db.public.t1 limit 1; SELECT test1; END;
CREATE PROCEDURE
> call test_redeclare('test');
  test1
---------
      1
(1 row)
> DROP PROCEDURE IF EXISTS test_declare;
DROP PROCEDURE
> CREATE PROCEDURE test_declare() BEGIN DECLARE "table" INT; SET "table" = 1; SELECT "table"; END;
CREATE PROCEDURE
> call test_declare();
  table
---------
      1
(1 row)
> DROP PROCEDURE IF EXISTS test_into;
DROP PROCEDURE
> CREATE PROCEDURE test_into() BEGIN DECLARE a1 INT; DECLARE a2 INT; select * into a1, a2 from t1; END;
ERROR: The used SELECT statements have a different number of columns
SQLSTATE: 42601
> use defaultdb;
SET
> drop database test_db cascade;
DROP DATABASE
> DROP PROCEDURE IF EXISTS test_declare_6;
DROP PROCEDURE
> CREATE PROCEDURE test_declare_6() BEGIN DECLARE test1 INT2 ;DECLARE test2 CHAR(10);DECLARE test3 FLOAT4;DECLARE test4 FLOAT4;DECLARE test5 DECIMAL;DECLARE test6 TIMESTAMP;SELECT test1,test2,test3,test4,test5,test6,length(test2);END;
CREATE PROCEDURE
> CALL test_declare_6();
  test1 | test2 | test3 | test4 | test5 | test6 | length
--------+-------+-------+-------+-------+-------+---------
  NULL  | NULL  | NULL  | NULL  | NULL  | NULL  |   NULL
(1 row)
> DROP PROCEDURE IF EXISTS test_declare_6;
DROP PROCEDURE
> DROP DATABASE IF EXISTS test_procedure_my_rel_null CASCADE;
DROP DATABASE
> DROP DATABASE IF EXISTS test_procedure_my_ts_null CASCADE;
DROP DATABASE
> CREATE DATABASE test_procedure_my_rel_null ;
CREATE DATABASE
> CREATE TS DATABASE test_procedure_my_ts_null ;
CREATE TS DATABASE
> CREATE TABLE test_procedure_my_ts_null.test1(---更改
k_ts TIMESTAMPTZ NOT NULL, ----TIMESTAMP 、TIMESTAMPTZ、TIMESTAMP(3)
id INT NOT NULL,e1 INT)
    TAGS (
code1 INT2 NOT NULL)
PRIMARY TAGS(code1);
CREATE TABLE
> INSERT INTO test_procedure_my_ts_null.test1 VALUES('2024-1-1 08:00:00.1' ,1,NULL,1);
INSERT 1
> INSERT INTO test_procedure_my_ts_null.test1 VALUES('2024-2-1 16:00:00.01' ,2,NULL,2);
INSERT 1
> INSERT INTO test_procedure_my_ts_null.test1 VALUES('2024-3-1 23:59:59.999',3,NULL,3);
INSERT 1
> CREATE TABLE test_procedure_my_ts_null.test2(---更改
k_ts TIMESTAMPTZ NOT NULL, ----TIMESTAMP 、TIMESTAMPTZ、TIMESTAMP(3)
id INT NOT NULL,e1 INT)
    TAGS (
code1 INT2 NOT NULL)
PRIMARY TAGS(code1);
CREATE TABLE
> DROP PROCEDURE IF EXISTS test_procedure_my_ts_null.test_null;
DROP PROCEDURE
> CREATE PROCEDURE test_procedure_my_ts_null.test_null(i1 INT) BEGIN DECLARE test1 TIMESTAMPTZ;DECLARE test2 INT;DECLARE test3 INT;DECLARE test4 INT; SELECT  k_ts,id,e1,code1 INTO test1,test2,test3,test4 FROM test_procedure_my_ts_null.test1 WHERE id = i1; INSERT INTO test_procedure_my_ts_null.test2 values(test1,test2,test3,test4); SELECT 1; END;
CREATE PROCEDURE
> CALL test_procedure_my_ts_null.test_null(1);
  ?column?
------------
         1
(1 row)
> select *from test_procedure_my_ts_null.test2;
             k_ts             | id |  e1  | code1
------------------------------+----+------+--------
  2024-01-01 08:00:00.1+00:00 |  1 | NULL |     1
(1 row)
> DROP DATABASE IF EXISTS test_procedure_my_rel_null CASCADE;
DROP DATABASE
> DROP DATABASE IF EXISTS test_procedure_my_ts_null CASCADE;
DROP DATABASE
> CREATE DATABASE test_procedure_my_cursor_cursor_rel;
CREATE DATABASE
> DROP TABLE IF EXISTS test_procedure_my_cursor_cursor_rel.test1 CASCADE;
DROP TABLE
> CREATE TABLE test_procedure_my_cursor_cursor_rel.test1 (t1 INT,t2 VARCHAR);
CREATE TABLE
> INSERT INTO test_procedure_my_cursor_cursor_rel.test1 VALUES(1,'A');
INSERT 1
> INSERT INTO test_procedure_my_cursor_cursor_rel.test1 VALUES(2,'B');
INSERT 1
> INSERT INTO test_procedure_my_cursor_cursor_rel.test1 VALUES(3,'C');
INSERT 1
> DROP PROCEDURE IF EXISTS test_procedure_my_cursor_cursor_rel.test_cursor_2;
DROP PROCEDURE
> CREATE PROCEDURE test_procedure_my_cursor_cursor_rel.test_cursor_2() BEGIN DECLARE val1 INT;DECLARE val2 VARCHAR;DECLARE val3 VARCHAR;DECLARE cur1 CURSOR FOR SELECT * FROM test_procedure_my_cursor_cursor_rel.test1 WHERE t1 IN(1,2) ORDER BY t1 desc;OPEN cur1;FETCH cur1 INTO val1,val2;DECLARE cur1 CURSOR FOR SELECT * FROM test_procedure_my_cursor_cursor_rel.test1 WHERE t1 NOT IN(1,2) ORDER BY t1 desc;SELECT val1,val2;CLOSE cur1;END;
ERROR: duplicate cursor: "cur1"
SQLSTATE: 42701
> DROP PROCEDURE test_procedure_my_cursor_cursor_rel.test_cursor_2;
ERROR: procedure "test_procedure_my_cursor_cursor_rel.test_cursor_2" does not exist
SQLSTATE: 42704
> CREATE PROCEDURE test_procedure_my_cursor_cursor_rel.test_cursor_3() BEGIN DECLARE val1 INT;DECLARE val2 int;DECLARE val3 int;DECLARE cur1 CURSOR FOR SELECT * FROM test_procedure_my_cursor_cursor_rel.test1 WHERE t1 IN(1,2) ORDER BY t1 desc;DECLARE cur1 CURSOR FOR SELECT * FROM test_procedure_my_cursor_cursor_rel.test1 WHERE t1 NOT IN(1,2) ORDER BY t1 desc;OPEN cur1;FETCH cur1 INTO val1,val2;SELECT val1,val2;CLOSE cur1;END;
ERROR: duplicate cursor: "cur1"
SQLSTATE: 42701
> DROP PROCEDURE test_procedure_my_cursor_cursor_rel.test_cursor_3;
ERROR: procedure "test_procedure_my_cursor_cursor_rel.test_cursor_3" does not exist
SQLSTATE: 42704
> DROP PROCEDURE IF EXISTS test_procedure_my_cursor_cursor_rel.test_cursor_4;
DROP PROCEDURE
> CREATE PROCEDURE test_procedure_my_cursor_cursor_rel.test_cursor_4()BEGIN DECLARE val1 INT DEFAULT 100000;OPEN cur1;FETCH cur1 INTO val1;SELECT val1;END;
ERROR: variable name: cur1 does not exist
SQLSTATE: 42704
> CALL test_procedure_my_cursor_cursor_rel.test_cursor_4();
ERROR: procedure "test_procedure_my_cursor_cursor_rel.test_cursor_4" does not exist
SQLSTATE: 42704
> CALL test_procedure_my_cursor_cursor_rel.test_cursor_4();
ERROR: procedure "test_procedure_my_cursor_cursor_rel.test_cursor_4" does not exist
SQLSTATE: 42704
> CREATE PROCEDURE test_procedure_my_cursor_cursor_rel.test_cursor_5()BEGIN DECLARE val1 INT DEFAULT 100000;FETCH cur1 INTO val1;SELECT val1;END;
ERROR: variable name: cur1 does not exist
SQLSTATE: 42704
> CALL test_procedure_my_cursor_cursor_rel.test_cursor_5();
ERROR: procedure "test_procedure_my_cursor_cursor_rel.test_cursor_5" does not exist
SQLSTATE: 42704
> CALL test_procedure_my_cursor_cursor_rel.test_cursor_5();
ERROR: procedure "test_procedure_my_cursor_cursor_rel.test_cursor_5" does not exist
SQLSTATE: 42704
> DROP DATABASE IF EXISTS test_procedure_my_cursor_cursor_rel CASCADE;
DROP DATABASE
> DROP DATABASE IF EXISTS test_procedure_my_limit_ts CASCADE;
DROP DATABASE
> CREATE TS DATABASE test_procedure_my_limit_ts;
CREATE TS DATABASE
> CREATE TABLE test_procedure_my_limit_ts.test2(---更改
k_timestamp TIMESTAMPTZ NOT NULL, ----TIMESTAMP 、TIMESTAMPTZ、TIMESTAMP(3)
id INT NOT NULL,
e1 INT2,
e2 INT2,
e3 VARCHAR)
TAGS (
code1 INT2 NOT NULL,
code2 VARCHAR,
code3 VARCHAR)
PRIMARY TAGS(code1);
CREATE TABLE
> INSERT INTO test_procedure_my_limit_ts.test2 VALUES('2024-1-1 08:00:00.1'  ,1,1,1,'a',1,'a','a');
INSERT 1
> INSERT INTO test_procedure_my_limit_ts.test2 VALUES('2024-2-1 16:00:00.01' ,2,2,2,'b',2,'b','b');
INSERT 1
> INSERT INTO test_procedure_my_limit_ts.test2 VALUES('2024-3-1 23:59:59.999',3,3,3,'c',3,'c','c');
INSERT 1
> DROP PROCEDURE IF EXISTS test_procedure_my_limit_ts.test_limit;
DROP PROCEDURE
> CREATE PROCEDURE test_procedure_my_limit_ts.test_limit(i1 INT) BEGIN DELETE FROM test_procedure_my_limit_ts.test2 WHERE code1 = i1; END;
CREATE PROCEDURE
> select *from test_procedure_my_limit_ts.test2 order by id;
           k_timestamp          | id | e1 | e2 | e3 | code1 | code2 | code3
--------------------------------+----+----+----+----+-------+-------+--------
  2024-01-01 08:00:00.1+00:00   |  1 |  1 |  1 | a  |     1 | a     | a
  2024-02-01 16:00:00.01+00:00  |  2 |  2 |  2 | b  |     2 | b     | b
  2024-03-01 23:59:59.999+00:00 |  3 |  3 |  3 | c  |     3 | c     | c
(3 rows)
> CALL test_procedure_my_limit_ts.test_limit(1);
CALL PROCEDURE
> select *from test_procedure_my_limit_ts.test2 order by id;
           k_timestamp          | id | e1 | e2 | e3 | code1 | code2 | code3
--------------------------------+----+----+----+----+-------+-------+--------
  2024-02-01 16:00:00.01+00:00  |  2 |  2 |  2 | b  |     2 | b     | b
  2024-03-01 23:59:59.999+00:00 |  3 |  3 |  3 | c  |     3 | c     | c
(2 rows)
> CALL test_procedure_my_limit_ts.test_limit(3);
CALL PROCEDURE
> select *from test_procedure_my_limit_ts.test2 order by id;
          k_timestamp          | id | e1 | e2 | e3 | code1 | code2 | code3
-------------------------------+----+----+----+----+-------+-------+--------
  2024-02-01 16:00:00.01+00:00 |  2 |  2 |  2 | b  |     2 | b     | b
(1 row)
> DROP PROCEDURE IF EXISTS test_procedure_my_limit_ts.test_limit;
DROP PROCEDURE
> CREATE PROCEDURE test_procedure_my_limit_ts.test_limit(i1 timestamp) BEGIN DELETE FROM test_procedure_my_limit_ts.test2 WHERE k_timestamp = i1; END;
ERROR: declared variable "i1" cannot be used on column "k_timestamp"
SQLSTATE: 0A000
> DROP PROCEDURE IF EXISTS test_procedure_my_limit_ts.test_limit;
DROP PROCEDURE
> CREATE PROCEDURE test_procedure_my_limit_ts.test_limit(i1 INT) BEGIN UPDATE test_procedure_my_limit_ts.test2 set code2='test' WHERE code1 = i1; END;
ERROR: unsupported conditions in update: cannot use declared variable "i1" in time-series
SQLSTATE: 0A000
> DROP DATABASE IF EXISTS test_procedure_my_limit_ts CASCADE;
DROP DATABASE
> DROP DATABASE IF EXISTS test_procedure_my_limit_ts CASCADE;
DROP DATABASE
> DROP DATABASE IF EXISTS test_procedure_my_limit_rel CASCADE;
DROP DATABASE
> CREATE TS DATABASE test_procedure_my_limit_ts;
CREATE TS DATABASE
> CREATE DATABASE test_procedure_my_limit_rel;
CREATE DATABASE
> DROP PROCEDURE IF EXISTS test_procedure_my_limit_rel.test_limit;
DROP PROCEDURE
> CREATE TABLE test_procedure_my_limit_ts.test2(
k_timestamp TIMESTAMPTZ NOT NULL,
id INT NOT NULL,
e1 INT2,
e2 INT2,
e3 VARCHAR)
TAGS (
code1 INT2 NOT NULL,
code2 VARCHAR,
code3 VARCHAR)
PRIMARY TAGS(code1);
CREATE TABLE
> INSERT INTO test_procedure_my_limit_ts.test2 VALUES('2024-1-1 08:00:00.1'  ,1,1,1,'a',1,'a','a');
INSERT 1
> INSERT INTO test_procedure_my_limit_ts.test2 VALUES('2024-2-1 16:00:00.01' ,2,2,2,'b',2,'b','b');
INSERT 1
> INSERT INTO test_procedure_my_limit_ts.test2 VALUES('2024-3-1 23:59:59.999',3,3,3,'c',3,'c','c');
INSERT 1
> CREATE PROCEDURE test_procedure_my_limit_ts.test_limit(i1 INT) $$BEGIN UPDATE test_procedure_my_limit_ts.test2 SET code2 = 'test' WHERE code1 = 1; END$$;
CREATE PROCEDURE
> ALTER TABLE test_procedure_my_limit_ts.test2 RENAME TAG code2  TO code222;
ERROR: cannot rename tag "code2" because procedure "test_procedure_my_limit_ts.public.test_limit" depends on it
SQLSTATE: 2BP01
HINT: you can drop test_procedure_my_limit_ts.public.test_limit instead.
> CALL test_procedure_my_limit_ts.test_limit(1);
CALL PROCEDURE
> ALTER TABLE test_procedure_my_limit_ts.test2 RENAME TAG code222 TO code2;
ERROR: column "code222" does not exist
SQLSTATE: 42703
> DROP DATABASE IF EXISTS test_procedure_my_limit_ts CASCADE;
DROP DATABASE
> DROP DATABASE IF EXISTS test_procedure_my_limit_rel CASCADE;
DROP DATABASE
> drop table if exists t1 cascade;
DROP TABLE
> create table t1(a int, b int);
CREATE TABLE
> create procedure p1() begin update t1 set a =1 where b=0; end;
CREATE PROCEDURE
> alter table t1 rename column a to aa;
ERROR: cannot rename column "a" because procedure "defaultdb.public.p1" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.p1 instead.
> alter table t1 rename column b to bb;
ERROR: cannot rename column "b" because procedure "defaultdb.public.p1" depends on it
SQLSTATE: 2BP01
HINT: you can drop defaultdb.public.p1 instead.
> drop table if exists t1 cascade;
DROP TABLE
> create procedure p1();
ERROR: at or near "EOF": syntax error: the procedure body is missing
SQLSTATE: 42601
DETAIL: source SQL:
create procedure p1()
                     ^
> create procedure p1(a int);
ERROR: at or near "EOF": syntax error: the procedure body is missing
SQLSTATE: 42601
DETAIL: source SQL:
create procedure p1(a int)
                          ^
> create procedure p1(a int) $$ begin declare b int; declare c int; end; select b,c;$$;
ERROR: please put the statement into the body of BEGIN...END
SQLSTATE: 42P13
> create procedure p1(a int) $$ begin declare b int; declare c int; end;$$ begin select b,c; end;
ERROR: at or near "EOF": syntax error: body-string and body-block cannot occur simultaneously
SQLSTATE: 42601
DETAIL: source SQL:
create procedure p1(a int) $$ begin declare b int; declare c int; end;$$ begin select b,c; end
                                                                                              ^
> create procedure p1(a int) $$ begin declare b int; declare c int; select a,b,c; end$$;
CREATE PROCEDURE
> call p1(111);
   a  |  b   |  c
------+------+-------
  111 | NULL | NULL
(1 row)
> drop procedure p1;
DROP PROCEDURE
> DROP DATABASE IF EXISTS test_procedure_my_rel CASCADE;
DROP DATABASE
> create database test_procedure_my_rel;
CREATE DATABASE
> DROP PROCEDURE IF EXISTS test_procedure_my_rel.test_input_5;
DROP PROCEDURE
> CREATE PROCEDURE test_procedure_my_rel.test_input_5(a INT2,b INT4,c INT8)
    $$ BEGIN SELECT a,b,c;END $$ ;
CREATE PROCEDURE
> CALL test_procedure_my_rel.test_input_5(99.99,-1981.389,1982.193);
ERROR: expected Parameter expression to have type int2, but '99.99' has type decimal
> CALL test_procedure_my_rel.test_input_5(99.99,-1981.389,1982.193);
ERROR: expected Parameter expression to have type int2, but '99.99' has type decimal
> DROP DATABASE IF EXISTS test_procedure_my_rel CASCADE;
DROP DATABASE
