> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> create trigger trig1 before insert on tt for each row begin insert into tt1 values (new.a); insert into tt2 values (new.b);end;
CREATE TRIGGER
> create trigger trig2 after insert on tt for each row begin delete from tt1 where a=new.a; delete from tt2 where b=new.b;end;
CREATE TRIGGER
> show create trigger trig1 on tt;
  trigger_name |                            create_statement
---------------+--------------------------------------------------------------------------
  trig1        | CREATE TRIGGER trig1 BEFORE INSERT ON defaultdb.public.tt FOR EACH ROW
               | BEGIN
               | INSERT INTO tt1 VALUES (new.a);
               | INSERT INTO tt2 VALUES (new.b);
               | END;
(1 row)
> insert into tt values (123,456);
INSERT 1
> select * from tt;
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1;
  a
-----
(0 rows)
> select * from tt2;
  b
-----
(0 rows)
> drop table if exists tt;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create trigger trig1 before insert on tt for each row begin insert into tt1 values (1); insert into tt2 values (123123123123); end;
CREATE TRIGGER
> insert into tt values (123, 456);
ERROR: TriggeredActionException: integer out of range for type int4 (column "b")
SQLSTATE: 09000
> select * from tt;
  a | b
----+----
(0 rows)
> select * from tt1;
  a
-----
(0 rows)
> select * from tt2;
  b
-----
(0 rows)
> drop trigger trig1 on tt;
DROP TRIGGER
> create trigger trig1 before insert on tt for each row begin insert into tt1 values (1); end;
CREATE TRIGGER
> insert into tt values (123123123123,123123123123);
ERROR: integer out of range for type int4 (column "a")
SQLSTATE: 22003
> select * from tt;
  a | b
----+----
(0 rows)
> select * from tt1;
  a
-----
(0 rows)
> create trigger trig2 after insert on tt for each row begin insert into tt1 values (123123123123);end;
CREATE TRIGGER
> insert into tt values (123, 456);
ERROR: TriggeredActionException: integer out of range for type int4 (column "a")
SQLSTATE: 09000
> select * from tt;
  a | b
----+----
(0 rows)
> select * from tt1;
  a
-----
(0 rows)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int primary key, b int);
CREATE TABLE
> create index idx1 on tt(b);
CREATE INDEX
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> insert into tt values (66,7);
INSERT 1
> insert into tt1 values (7);
INSERT 1
> insert into tt2 values (66);
INSERT 1
> select * from tt;
  a  | b
-----+----
  66 | 7
(1 row)
> select * from tt1;
  a
-----
  7
(1 row)
> select * from tt2;
  b
------
  66
(1 row)
> create trigger trig1 before delete on tt for each row begin delete from tt1 where a = old.b; delete from tt2 where b = old.a;end;
CREATE TRIGGER
> create trigger trig2 after delete on tt for each row begin insert into tt1 values (old.a); insert into tt2 values (old.b);end;
CREATE TRIGGER
> delete from tt where a=66;
DELETE 1
> select * from tt;
  a | b
----+----
(0 rows)
> select * from tt1;
  a
------
  66
(1 row)
> select * from tt2;
  b
-----
  7
(1 row)
> drop trigger trig1 on tt;
DROP TRIGGER
> drop table if exists tt;
DROP TABLE
> create table tt(a int primary key, b int);
CREATE TABLE
> insert into tt values (123, 456);
INSERT 1
> insert into tt1 values (123);
INSERT 1
> create trigger trig1 before delete on tt for each row begin delete from tt1 where a=old.a; insert into tt1 values (123123123123); end;
CREATE TRIGGER
> delete from tt where a=123;
ERROR: TriggeredActionException: integer out of range for type int4 (column "a")
SQLSTATE: 09000
> select * from tt;
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1;
   a
-------
   66
  123
(2 rows)
> drop trigger trig1 on tt;
DROP TRIGGER
> create trigger trig1 before delete on tt for each row begin delete from tt1 where a=old.a; end;
CREATE TRIGGER
> delete from tt where a='stest';
ERROR: unsupported comparison operator: <int4> = <string>
SQLSTATE: 22023
> select * from tt;
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1;
   a
-------
   66
  123
(2 rows)
> create trigger trig2 after delete on tt for each row begin insert into tt1 values (123123123123);end;
CREATE TRIGGER
> delete from tt where a=123;
ERROR: TriggeredActionException: integer out of range for type int4 (column "a")
SQLSTATE: 09000
> select * from tt;
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1;
   a
-------
   66
  123
(2 rows)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> create trigger trig1 before update on tt for each row begin insert into tt1 values (new.b); insert into tt2 values (old.b);end;
CREATE TRIGGER
> create trigger trig2 after update on tt for each row begin insert into tt1 values (old.b); insert into tt2 values (old.a);end;
CREATE TRIGGER
> insert into tt values (123,456);
INSERT 1
> update tt set b=789 where b= 456;
UPDATE 1
> select * from tt; --123,789
   a  |  b
------+------
  123 | 789
(1 row)
> select * from tt1; --789,456
   a
-------
  789
  456
(2 rows)
> select * from tt2; --456,123
   b
-------
  456
  123
(2 rows)
> drop table if exists tt;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create trigger trig1 before update on tt for each row begin insert into tt1 values (123123123123); end;
CREATE TRIGGER
> insert into tt values (123, 456);
INSERT 1
> update tt set b=567 where a= 123;
ERROR: TriggeredActionException: integer out of range for type int4 (column "a")
SQLSTATE: 09000
> select * from tt;
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1;
   a
-------
  789
  456
(2 rows)
> drop trigger trig1 on tt;
DROP TRIGGER
> create trigger trig1 before update on tt for each row begin insert into tt1 values (old.a); end;
CREATE TRIGGER
> update tt set b=123123123123 where a= 123;
ERROR: integer out of range for type int4 (column "b")
SQLSTATE: 22003
> select * from tt;
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1;
   a
-------
  789
  456
(2 rows)
> create trigger trig2 after update on tt for each row begin insert into tt1 values (123123123123);end;
CREATE TRIGGER
> update tt set b=567 where a= 123;
ERROR: TriggeredActionException: integer out of range for type int4 (column "a")
SQLSTATE: 09000
> select * from tt;
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1;
   a
-------
  789
  456
(2 rows)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int primary key, b int unique);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> create trigger trig1 before insert on tt for each row begin insert into tt1 values (new.a); insert into tt2 values (new.b);end;
CREATE TRIGGER
> create trigger trig2 before update on tt for each row begin insert into tt1 values (new.b); insert into tt2 values (old.b);end;
CREATE TRIGGER
> insert into tt values (123,456); -- 触发insert触发器
INSERT 1
> select * from tt;  -- 123,456
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1; -- 123
   a
-------
  123
(1 row)
> select * from tt2; -- 456
   b
-------
  456
(1 row)
> insert into tt values (123,456) on conflict (b) do update set b=789; -- 不触发触发器
INSERT 1
> select * from tt;  -- 123,789
   a  |  b
------+------
  123 | 789
(1 row)
> select * from tt1; -- 123
   a
-------
  123
(1 row)
> select * from tt2; -- 456
   b
-------
  456
(1 row)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int primary key, b int);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> create trigger trig1 before insert on tt for each row begin insert into tt1 values (new.a) on conflict(a) do nothing; end;
ERROR: INSERT ... ON CONFLICT is not supported in trigger definition
SQLSTATE: 0A000
> create trigger trig2 before update on tt for each row begin upsert tt1 values (new.b);end;
ERROR: at or near "upsert": syntax error
SQLSTATE: 42601
DETAIL: source SQL:
create trigger trig2 before update on tt for each row begin upsert tt1 values (new.b);end
                                                            ^
HINT: try \h CREATE TRIGGER
> upsert into tt values (123,456);
INSERT 1
> select * from tt;  -- 123,456
   a  |  b
------+------
  123 | 456
(1 row)
> select * from tt1; -- 空
  a
-----
(0 rows)
> select * from tt2; -- 空
  b
-----
(0 rows)
> upsert into tt values (123,789);
INSERT 1
> select * from tt;  -- 123,789
   a  |  b
------+------
  123 | 789
(1 row)
> select * from tt1; -- 空
  a
-----
(0 rows)
> select * from tt2; -- 空
  b
-----
(0 rows)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> create trigger trig1 before insert on tt for each row begin insert into tt1 values (new.a); insert into tt2 values (new.a);end;
CREATE TRIGGER
> create trigger trig1 before insert on tt1 for each row begin insert into tt2 values (new.a);end;
CREATE TRIGGER
> create trigger trig1 before insert on tt2 for each row begin insert into tt values (new.b);end; --create成功
CREATE TRIGGER
> insert into tt values (1,2); --报错，因为tt被循环引用了
ERROR: Can't update table tt in trigger because it is already used by statement which invoked this trigger.
SQLSTATE: 42P13
> drop table if exists sales;
DROP TABLE
> drop table if exists sales_summary;
DROP TABLE
> CREATE TABLE sales (sale_id INT, amount int);
CREATE TABLE
> CREATE TABLE sales_summary (total_sales int, sale_id int);
CREATE TABLE
> CREATE TRIGGER update_summary
    AFTER INSERT ON sales
    FOR EACH ROW
BEGIN UPDATE sales_summary SET total_sales = total_sales + NEW.amount, sale_id = sale_id + new.sale_id where true; END;;
CREATE TRIGGER
> insert into sales_summary values (0,0);
INSERT 1
> INSERT INTO sales VALUES (1, 200), (2, 300);
INSERT 2
> SELECT * FROM sales_summary; -- 验证结果为500
  total_sales | sale_id
--------------+----------
          500 |       3
(1 row)
> drop table if exists orders ;
DROP TABLE
> CREATE TABLE orders (
id INT PRIMARY KEY,
amount DECIMAL(10,2),
created_at timestamp);
CREATE TABLE
> CREATE TRIGGER set_order_date
    BEFORE INSERT ON orders
    FOR EACH ROW
BEGIN SET NEW.created_at = '2025-07-10 01:30:22'; END;
CREATE TRIGGER
> INSERT INTO orders (id, amount) VALUES (1, 100.50);
INSERT 1
> SELECT created_at FROM orders;
         created_at
-----------------------------
  2025-07-10 01:30:22+00:00
(1 row)
> drop table if exists employees ;
DROP TABLE
> CREATE TABLE employees (
id INT PRIMARY KEY,
salary DECIMAL(10,2)
);
CREATE TABLE
> CREATE TRIGGER prevent_salary_decrease
    BEFORE UPDATE ON employees
    FOR EACH ROW
BEGIN IF NEW.salary < OLD.salary THEN SET new.salary = old.salary; ENDIF; END;
CREATE TRIGGER
> INSERT INTO employees VALUES (1, 5000);
INSERT 1
> UPDATE employees SET salary = 4000 WHERE id=1;
UPDATE 1
> select * from employees; --期望是5000
  id | salary
-----+----------
   1 | 5000.00
(1 row)
> drop table if exists employees ;
DROP TABLE
> CREATE TABLE employees (
id INT PRIMARY KEY,
name STRING,
age INT,
salary DECIMAL(10,2)
);
CREATE TABLE
> CREATE TRIGGER prevent_salary_decrease
    BEFORE UPDATE ON employees
    FOR EACH ROW
BEGIN IF NEW.salary < OLD.salary THEN SET new.salary = old.salary; ENDIF; END;
CREATE TRIGGER
> INSERT INTO employees VALUES (1, 'name1', 99, 5000);
INSERT 1
> UPDATE employees SET salary = 4000 WHERE id=1;
UPDATE 1
> select * from employees; --期望是5000
  id | name  | age | salary
-----+-------+-----+----------
   1 | name1 |  99 | 5000.00
(1 row)
> drop table if exists users;
DROP TABLE
> drop table if exists logs ;
DROP TABLE
> CREATE TABLE users (user_id INT PRIMARY KEY);
CREATE TABLE
> CREATE TABLE logs (log_id INT, user_id INT, action VARCHAR(20));
CREATE TABLE
> CREATE TRIGGER delete_user_logs
    AFTER DELETE ON users
    FOR EACH ROW
BEGIN DELETE FROM logs WHERE user_id = OLD.user_id; END;;
CREATE TRIGGER
> INSERT INTO users VALUES (101);
INSERT 1
> INSERT INTO logs VALUES (1, 101, 'login'), (2, 101, 'logout');
INSERT 2
> DELETE FROM users WHERE user_id=101;
DELETE 1
> SELECT COUNT(*) FROM logs; -- 验证结果为0
  count
---------
      0
(1 row)
> drop table if exists products;
DROP TABLE
> CREATE TABLE products (
id INT,
name VARCHAR(50) NOT NULL
);
CREATE TABLE
> CREATE TRIGGER set_default_name
    BEFORE INSERT ON products
    FOR EACH ROW
BEGIN IF NEW.name IS NULL THEN SET NEW.name = 'Unnamed'; ENDIF; END;
CREATE TRIGGER
> INSERT INTO products (id) VALUES (100);
INSERT 1
> SELECT name FROM products; -- 验证结果为'Unnamed'
   name
-----------
  Unnamed
(1 row)
> drop table if exists audit_log ;
DROP TABLE
> CREATE TABLE audit_log (message VARCHAR(100));
CREATE TABLE
> drop table if exists orders;
DROP TABLE
> create table orders (amount int);
CREATE TABLE
> CREATE TRIGGER trig1
    BEFORE INSERT ON orders
    FOR EACH ROW
BEGIN INSERT INTO audit_log VALUES ('BEFORE INSERT'); END;
CREATE TRIGGER
> CREATE TRIGGER trig2
    AFTER INSERT ON orders
    FOR EACH ROW
BEGIN INSERT INTO audit_log VALUES ('AFTER INSERT'); END;
CREATE TRIGGER
> INSERT INTO orders (amount) VALUES (50);
INSERT 1
> SELECT * FROM audit_log; -- 验证顺序: BEFORE → AFTER
     message
-----------------
  BEFORE INSERT
  AFTER INSERT
(2 rows)
> drop table if exists audit_log ;
DROP TABLE
> CREATE TABLE audit_log (message VARCHAR(100));
CREATE TABLE
> drop table if exists orders;
DROP TABLE
> create table orders (amount int);
CREATE TABLE
> CREATE TRIGGER trig1
    after INSERT ON orders
    FOR EACH ROW
BEGIN INSERT INTO audit_log VALUES ('BEFORE INSERT'); END;
CREATE TRIGGER
> CREATE TRIGGER trig2
    before INSERT ON orders
    FOR EACH ROW
BEGIN INSERT INTO audit_log VALUES ('AFTER INSERT'); END;
CREATE TRIGGER
> CREATE TRIGGER trig11
    after INSERT ON orders
    FOR EACH ROW
BEGIN INSERT INTO audit_log VALUES ('BEFORE INSERT'); END;
CREATE TRIGGER
> CREATE TRIGGER trig22
    before INSERT ON orders
    FOR EACH ROW
BEGIN INSERT INTO audit_log VALUES ('AFTER INSERT'); END;
CREATE TRIGGER
> select trigger_name,trigger_action_time,trigger_order from [show triggers from orders]; -- trig2的order是1，trig22的order是2， trig1的order是3, trig11的order是4,
  trigger_name | trigger_action_time | trigger_order
---------------+---------------------+----------------
  trig2        | BEFORE              |             1
  trig22       | BEFORE              |             2
  trig1        | AFTER               |             3
  trig11       | AFTER               |             4
(4 rows)
> CREATE TRIGGER trig3
    after INSERT ON orders
    FOR EACH ROW precedes trig2
BEGIN INSERT INTO audit_log VALUES ('BEFORE INSERT'); END;
ERROR: referenced trigger "trig2" for the given action time and event type does not exist
SQLSTATE: 42P17
> CREATE TRIGGER trig4
    before INSERT ON orders
    FOR EACH ROW follows trig1
BEGIN INSERT INTO audit_log VALUES ('BEFORE INSERT'); END;
ERROR: referenced trigger "trig1" for the given action time and event type does not exist
SQLSTATE: 42P17
> CREATE TRIGGER trig3
    after INSERT ON orders
    FOR EACH ROW precedes trig1
BEGIN INSERT INTO audit_log VALUES ('BEFORE INSERT'); END;
CREATE TRIGGER
> CREATE TRIGGER trig4
    before INSERT ON orders
    FOR EACH ROW follows trig2
BEGIN INSERT INTO audit_log VALUES ('BEFORE INSERT'); END;
CREATE TRIGGER
> select trigger_name,trigger_action_time,trigger_order from [show triggers from orders]; --顺序为：trig2，trig4，trig22，trig3，trig1，trig11
  trigger_name | trigger_action_time | trigger_order
---------------+---------------------+----------------
  trig2        | BEFORE              |             1
  trig4        | BEFORE              |             2
  trig22       | BEFORE              |             3
  trig3        | AFTER               |             4
  trig1        | AFTER               |             5
  trig11       | AFTER               |             6
(6 rows)
> drop table if exists counter;
DROP TABLE
> CREATE TABLE counter (val INT);
CREATE TABLE
> CREATE TRIGGER recursive_trigger
    AFTER UPDATE ON counter
    FOR EACH ROW
BEGIN UPDATE counter SET val = val + 1 where val = 1; END;
CREATE TRIGGER
> INSERT INTO counter VALUES (1);
INSERT 1
> UPDATE counter SET val = 2 where val = 1; -- 验证递归深度限制（MySQL默认禁止）
ERROR: Can't update table counter in trigger because it is already used by statement which invoked this trigger.
SQLSTATE: 42P13
> drop database if exists other_db cascade;
DROP DATABASE
> create database other_db;
CREATE DATABASE
> create table other_db.logs(id int);
CREATE TABLE
> drop table if exists orders;
DROP TABLE
> create table orders(id int);
CREATE TABLE
> CREATE TRIGGER cross_db_trigger
    AFTER INSERT ON orders
    FOR EACH ROW
BEGIN INSERT INTO other_db.logs VALUES (NEW.id); END;
CREATE TRIGGER
> insert into orders values (123); --根据用户权限，应该成功
INSERT 1
> select * from other_db.logs; --根据用户权限，结果应为123
  id
-------
  123
(1 row)
> drop table if exists orders;
DROP TABLE
> create table orders(amount float);
CREATE TABLE
> CREATE TRIGGER modify_data
    BEFORE INSERT ON orders
    FOR EACH ROW
BEGIN SET NEW.amount = NEW.amount * 0.9; END;
CREATE TRIGGER
> INSERT INTO orders (amount) VALUES (100);
INSERT 1
> SELECT amount FROM orders; -- 验证结果为90
  amount
----------
      90
(1 row)
> drop table if exists orders;
DROP TABLE
> drop table if exists other_table;
DROP TABLE
> create table orders(id int);
CREATE TABLE
> create table other_table(id int);
CREATE TABLE
> set @udv1 = 123;
SET
> CREATE TRIGGER dynamic_sql
    AFTER INSERT ON orders
    FOR EACH ROW
BEGIN insert into other_table values (@udv1); END;
CREATE TRIGGER
> INSERT INTO orders (id) VALUES (75);
INSERT 1
> select * from other_table; -- 结果为123
  id
-------
  123
(1 row)
> drop table if exists orders;
DROP TABLE
> drop table if exists other;
DROP TABLE
> create table orders(amount float);
CREATE TABLE
> create table other(a float);
CREATE TABLE
> CREATE TRIGGER test_precedes
    before INSERT ON orders
    FOR EACH ROW
BEGIN set new.amount = new.amount+1; insert into other values (new.amount); END;
CREATE TRIGGER
> CREATE TRIGGER test_precedes_1
    BEFORE INSERT ON orders
    FOR EACH ROW PRECEDES not_exist
BEGIN set new.amount = new.amount+1; END;
ERROR: trigger "not_exist" does not exist
SQLSTATE: 42704
> CREATE TRIGGER test_precedes_1
    before INSERT ON orders
    FOR EACH ROW PRECEDES test_precedes
BEGIN set new.amount = new.amount + 999 ; insert into other values (new.amount); END;
CREATE TRIGGER
> insert into orders values (1);
INSERT 1
> select * from orders; -- 1001
  amount
----------
    1001
(1 row)
> select * from other; -- 1000 \n 1001
   a
--------
  1000
  1001
(2 rows)
> drop table if exists orders;
DROP TABLE
> drop table if exists other;
DROP TABLE
> create table orders(amount float);
CREATE TABLE
> create table other(a float);
CREATE TABLE
> CREATE TRIGGER test_precedes before INSERT ON orders FOR EACH ROW BEGIN set new.amount = new.amount+1;  insert into other values (new.amount);END;
CREATE TRIGGER
> CREATE TRIGGER test_precedes_1 BEFORE INSERT ON orders FOR EACH ROW PRECEDES not_exist BEGIN set new.amount = new.amount+1;END;
ERROR: trigger "not_exist" does not exist
SQLSTATE: 42704
> CREATE TRIGGER test_precedes_1
    after INSERT ON orders
    FOR EACH ROW
BEGIN set new.amount = new.amount + 999; insert into other values (new.amount);END;
ERROR: Updating of NEW row is not allowed in after trigger
SQLSTATE: 42P17
> insert into orders values (1);
INSERT 1
> select * from orders; -- 2
  amount
----------
       2
(1 row)
> select * from other; -- 2 \n 1001
  a
-----
  2
(1 row)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> set @udv = 1;
SET
> insert into tt1 values (666);
INSERT 1
> create trigger trig1 before insert on tt for each row begin select a into @udv from tt1; insert into tt2 values (@udv + new.b);  end;
CREATE TRIGGER
> insert into tt values (1,111);
INSERT 1
> select * from tt;
  a |  b
----+------
  1 | 111
(1 row)
> select * from tt2;
   b
-------
  112
(1 row)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> insert into tt1 values (666);
INSERT 1
> create trigger trig1 before insert on tt for each row begin insert into tt2 select new.a + a from tt1;  end;
CREATE TRIGGER
> insert into tt values (1,111);
INSERT 1
> select * from tt; --1,111
  a |  b
----+------
  1 | 111
(1 row)
> select * from tt2; -- 667
   b
-------
  667
(1 row)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int);
CREATE TABLE
> create table tt1(a int);
CREATE TABLE
> create table tt2(b int);
CREATE TABLE
> create trigger trig1 before insert on tt for each row begin if new.b < 0 then insert into tt2 values (new.b); set new.b=0; endif; insert into tt1 values (new.b); end;
CREATE TRIGGER
> insert into tt values (1,-1);
INSERT 1
> select * from tt; -- 1,0
  a | b
----+----
  1 | 0
(1 row)
> select * from tt1; -- 0
  a
-----
  0
(1 row)
> select * from tt2; -- -1
  b
------
  -1
(1 row)
> alter table tt drop column a;
ALTER TABLE
> insert into tt values (-123);
INSERT 1
> select * from tt; -- 0 \n 0
  b
-----
  0
  0
(2 rows)
> select * from tt1; -- 0 \n 0
  a
-----
  0
  0
(2 rows)
> select * from tt2; -- -1 \n -123
   b
--------
    -1
  -123
(2 rows)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int, c int);
CREATE TABLE
> create table tt1(a int, c int);
CREATE TABLE
> create table tt2(a int, c int);
CREATE TABLE
> insert into tt values (1,2,3);
INSERT 1
> create trigger trig1 before update on tt for each row begin if new.a < 0 then set new.a=0; insert into tt2 values (new.a, new.c); endif; insert into tt1 values (old.a, old.c); end;
CREATE TRIGGER
> update tt set a=-1, b=6, c=7 where a=1;
UPDATE 1
> select * from tt; -- 0,6,7
  a | b | c
----+---+----
  0 | 6 | 7
(1 row)
> select * from tt1; -- 1,3
  a | c
----+----
  1 | 3
(1 row)
> select * from tt2; -- 0,7
  a | c
----+----
  0 | 7
(1 row)
> alter table tt drop column b;
ALTER TABLE
> update tt set a=999, c=777 where a=0;
UPDATE 1
> select * from tt; -- 999, 777
   a  |  c
------+------
  999 | 777
(1 row)
> select * from tt1; -- 1,3 \n 0,7
  a | c
----+----
  1 | 3
  0 | 7
(2 rows)
> select * from tt2; -- 0,7
  a | c
----+----
  0 | 7
(1 row)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int, c int);
CREATE TABLE
> create table tt1(a int, b int);
CREATE TABLE
> insert into tt values (1,2,3);
INSERT 1
> create trigger trig1 before delete on tt for each row begin if old.b > 0 then set old.b = 777; insert into tt1 values (old.a, old.b); endif;end;
ERROR: Updating of OLD row is not allowed in trigger
SQLSTATE: 42P17
> delete from tt where a=1;
DELETE 1
> select * from tt; -- 空
  a | b | c
----+---+----
(0 rows)
> select * from tt1; -- 1, 777
  a | b
----+----
(0 rows)
> alter table tt drop column c;
ALTER TABLE
> insert into tt values (2,3);
INSERT 1
> delete from tt where a=2;
DELETE 1
> select * from tt; -- 空
  a | b
----+----
(0 rows)
> select * from tt1; -- 1,777 \n 2,777
  a | b
----+----
(0 rows)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> create table tt(a int, b int, c int);
CREATE TABLE
> create table tt1(a int, c int);
CREATE TABLE
> create table tt2(a int, c int);
CREATE TABLE
> insert into tt values (1,2,3);
INSERT 1
> create trigger trig1 before update on tt for each row begin if new.a < 0 then set new.a=0; insert into tt2 values (new.a, new.c); endif; insert into tt1 values (old.a, old.c); end;
CREATE TRIGGER
> update tt set a=-1, b=6, c=7 where a=1;
UPDATE 1
> select * from tt; -- 0,6,7
  a | b | c
----+---+----
  0 | 6 | 7
(1 row)
> select * from tt1; -- 1,3
  a | c
----+----
  1 | 3
(1 row)
> select * from tt2; -- 0,7
  a | c
----+----
  0 | 7
(1 row)
> alter table tt add column d string;
ALTER TABLE
> update tt set a=999, c=777 where a=0;
UPDATE 1
> select * from tt; -- 999, 6, 777, NULL
   a  | b |  c  |  d
------+---+-----+-------
  999 | 6 | 777 | NULL
(1 row)
> select * from tt1; -- 1,3 \n 0,7
  a | c
----+----
  1 | 3
  0 | 7
(2 rows)
> select * from tt2; -- 0,7
  a | c
----+----
  0 | 7
(1 row)
> drop table if exists tt,tt1,tt2;
DROP TABLE
> USE defaultdb;
SET
> DROP DATABASE IF EXISTS test_trigger_dxy cascade;
DROP DATABASE
> CREATE DATABASE test_trigger_dxy;
CREATE DATABASE
> CREATE TABLE test_trigger_dxy.t1(
tp  TIMESTAMPTZ NOT NULL,
id  INT NOT NULL,
e1  INT2,
e2  INT,
e3  INT8,
e4  FLOAT4,
e5  FLOAT8,
e6  BOOL,
e7  TIMESTAMP,
e8  CHAR(1023),
e9  NCHAR(255),
e10 VARCHAR(4096),
e11 CHAR,
e12 NCHAR,
e13 NVARCHAR(4096),
e14 VARBYTES,
e15 VARCHAR,
e16 NVARCHAR,
e17 BLOB,
e18 CLOB
);
CREATE TABLE
> CREATE TABLE test_trigger_dxy.t2(
tp  TIMESTAMPTZ NOT NULL,
id  INT NOT NULL,
e1  INT2,
e2  INT,
e3  INT8,
e4  FLOAT4,
e5  FLOAT8,
e6  BOOL,
e7  TIMESTAMP,
e8  CHAR(1023),
e9  NCHAR(255),
e10 VARCHAR(4096),
e11 CHAR,
e12 NCHAR,
e13 NVARCHAR(4096),
e14 VARBYTES,
e15 VARCHAR,
e16 NVARCHAR,
e17 BLOB,
e18 CLOB
);
CREATE TABLE
> CREATE TABLE test_trigger_dxy.t3(
tp  TIMESTAMPTZ NOT NULL,
id  INT NOT NULL,
e1  INT2,
e2  INT,
e3  INT8,
e4  FLOAT4,
e5  FLOAT8,
e6  BOOL,
e7  TIMESTAMP,
e8  CHAR(1023),
e9  NCHAR(255),
e10 VARCHAR(4096),
e11 CHAR,
e12 NCHAR,
e13 NVARCHAR(4096),
e14 VARBYTES,
e15 VARCHAR,
e16 NVARCHAR,
e17 BLOB,
e18 CLOB
);
CREATE TABLE
> INSERT INTO test_trigger_dxy.t1 VALUES('1970-01-01 00:00:00+00:00',1 ,0,0,0,0,0,true,'1970-01-01 00:00:00+00:00','','','','','','','','','','','');
INSERT 1
> select id,tp from test_trigger_dxy.t1;
  id |            tp
-----+----------------------------
   1 | 1970-01-01 00:00:00+00:00
(1 row)
> DROP TRIGGER IF EXISTS trig1 ON test_trigger_dxy.t1;
DROP TRIGGER
> CREATE TRIGGER trig1
BEFORE DELETE ON test_trigger_dxy.t1
FOR EACH ROW BEGIN INSERT INTO test_trigger_dxy.t2(id,tp) SELECT 11, OLD.tp FROM test_trigger_dxy.t1 ORDER BY id LIMIT 1; END;
CREATE TRIGGER
> delete from test_trigger_dxy.t1 where id=1;
DELETE 1
> select id,tp from test_trigger_dxy.t1;
  id | tp
-----+-----
(0 rows)
> select id,tp from test_trigger_dxy.t2;
  id |            tp
-----+----------------------------
  11 | 1970-01-01 00:00:00+00:00
(1 row)
> SET @dxy='0000-1-1 00:00:00';
SET
> DROP TRIGGER IF EXISTS trig1 ON test_trigger_dxy.t1;
DROP TRIGGER
> CREATE trigger trig1
BEFORE INSERT
ON test_trigger_dxy.t1 FOR EACH ROW BEGIN UPDATE test_trigger_dxy.t2 SET id=200 WHERE tp='1970-1-1 00:00:00.000' RETURNING tp; END;
ERROR: RETURNING with values is not supported in triggers
SQLSTATE: 0A000
> CREATE trigger trig1
BEFORE INSERT
ON test_trigger_dxy.t1 FOR EACH ROW BEGIN UPDATE test_trigger_dxy.t2 SET id=200 WHERE tp='1970-1-1 00:00:00.000' RETURNING tp::string INTO @dxy; END ;
CREATE TRIGGER
> INSERT INTO test_trigger_dxy.t1 VALUES('2262-05-11 23:47:16+00:00' ,21,-1 ,1 ,-1 ,1.125 ,-2.125 ,false,'2020-01-01 12:00:00+00:00' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'' ,'' ,'' ,'BUG' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'BUG' ,'BUG' );
INSERT 1
> SELECT @dxy;
            @dxy
-----------------------------
  1970-01-01 00:00:00+00:00
(1 row)
> DROP TRIGGER IF EXISTS trig1 ON test_trigger_dxy.t1;
DROP TRIGGER
> DROP TRIGGER IF EXISTS trig2 ON test_trigger_dxy.t1;
DROP TRIGGER
> DROP TRIGGER IF EXISTS trig3 ON test_trigger_dxy.t1;
DROP TRIGGER
> CREATE trigger trig1
BEFORE INSERT
ON test_trigger_dxy.t1 FOR EACH ROW BEGIN INSERT INTO test_trigger_dxy.t2 VALUES('2001-12-09 09:48:12.3+00:00' ,9 , null ,null ,null ,null ,null ,null ,null ,'BEFORE' ,null ,null ,null ,null ,null ,null ,null ,null ,null ,null );END ;
CREATE TRIGGER
> CREATE trigger trig3
BEFORE INSERT
ON test_trigger_dxy.t1 FOR EACH ROW BEGIN INSERT INTO test_trigger_dxy.t2 VALUES('2001-12-09 09:48:12.3+00:00' ,7 , null ,null ,null ,null ,null ,null ,null ,'BEFORE' ,null ,null ,null ,null ,null ,null ,null ,null ,null ,null );END ;
CREATE TRIGGER
> CREATE trigger trig2
BEFORE DELETE
ON test_trigger_dxy.t1 FOR EACH ROW
PRECEDES trig1 BEGIN INSERT INTO test_trigger_dxy.t2 VALUES('2001-12-09 09:48:12.3+00:00' ,8 , null ,null ,null ,null ,null ,null ,null ,'BEFORE' ,null ,null ,null ,null ,null ,null ,null ,null ,null ,null );END;
ERROR: referenced trigger "trig1" for the given action time and event type does not exist
SQLSTATE: 42P17
> DROP TRIGGER IF EXISTS trig1 ON test_trigger_dxy.t1;
DROP TRIGGER
> DROP TRIGGER IF EXISTS trig2 ON test_trigger_dxy.t1;
DROP TRIGGER
> DROP TRIGGER IF EXISTS trig3 ON test_trigger_dxy.t1;
DROP TRIGGER
> CREATE trigger trig2
BEFORE INSERT
ON test_trigger_dxy.t1 FOR EACH ROW BEGIN SET NEW.e1=NULL;INSERT INTO test_trigger_dxy.t2(tp,id,e1) VALUES('2970-1-1 00:00:00',NEW.id,NEW.e1);END;
CREATE TRIGGER
> select id,tp,e1 from test_trigger_dxy.t1;
  id |            tp             | e1
-----+---------------------------+-----
  21 | 2262-05-11 23:47:16+00:00 | -1
(1 row)
> select id,tp,e1 from test_trigger_dxy.t2;
  id  |            tp             |  e1
------+---------------------------+-------
  200 | 1970-01-01 00:00:00+00:00 | NULL
(1 row)
> INSERT INTO test_trigger_dxy.t1 VALUES('2262-05-11 23:47:16+00:00' ,21,-1 ,1 ,-1 ,1.125 ,-2.125 ,false,'2020-01-01 12:00:00+00:00' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'' ,'' ,'' ,'BUG' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'BUG' ,'BUG' );
INSERT 1
> select id,tp,e1 from test_trigger_dxy.t1;
  id |            tp             |  e1
-----+---------------------------+-------
  21 | 2262-05-11 23:47:16+00:00 |   -1
  21 | 2262-05-11 23:47:16+00:00 | NULL
(2 rows)
> select id,tp,e1 from test_trigger_dxy.t2;
  id  |            tp             |  e1
------+---------------------------+-------
  200 | 1970-01-01 00:00:00+00:00 | NULL
   21 | 2970-01-01 00:00:00+00:00 | NULL
(2 rows)
> DROP TRIGGER IF EXISTS trig1 ON test_trigger_dxy.t1;
DROP TRIGGER
> DROP TRIGGER IF EXISTS trig2 ON test_trigger_dxy.t1;
DROP TRIGGER
> DROP TRIGGER IF EXISTS trig3 ON test_trigger_dxy.t1;
DROP TRIGGER
> prepare p3 as CREATE trigger trig1
BEFORE INSERT
ON test_trigger_dxy.t1 FOR EACH ROW BEGIN INSERT INTO test_trigger_dxy.t2 VALUES('2001-12-09 09:48:12.3+00:00',NEW.id, -2,null,null,null,null,null,null ,null,null,null ,null ,null ,null ,null,null,null,null ,null );END ;
PREPARE
> execute p3;
CREATE TRIGGER
> show triggers from test_trigger_dxy.t1;
  trigger_name | trigger_action_time | trigger_event | trigger_order | on_table | enabled
---------------+---------------------+---------------+---------------+----------+----------
  trig1        | BEFORE              | INSERT        |             1 | t1       |  true
(1 row)
> select id,tp,e1 from test_trigger_dxy.t2 order by id;
  id  |            tp             |  e1
------+---------------------------+-------
   21 | 2970-01-01 00:00:00+00:00 | NULL
  200 | 1970-01-01 00:00:00+00:00 | NULL
(2 rows)
> INSERT INTO test_trigger_dxy.t1 VALUES('2262-05-11 23:47:16+00:00' ,21,-1 ,1 ,-1 ,1.125 ,-2.125 ,false,'2020-01-01 12:00:00+00:00' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'' ,'' ,'' ,'BUG' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'\0\0中文te@@~eng TE./。\0\0\0' ,'BUG' ,'BUG' );
INSERT 1
> select id,tp,e1 from test_trigger_dxy.t2 order by id;
  id  |             tp              |  e1
------+-----------------------------+-------
   21 | 2970-01-01 00:00:00+00:00   | NULL
   21 | 2001-12-09 09:48:12.3+00:00 |   -2
  200 | 1970-01-01 00:00:00+00:00   | NULL
(3 rows)
> DROP DATABASE IF EXISTS test_trigger_dxy cascade;
DROP DATABASE
> drop database IF EXISTS d3 cascade;
DROP DATABASE
> CREATE DATABASE d3;
CREATE DATABASE
> use d3;
SET
> CREATE TABLE d3.t3(
  id  INT NOT NULL,
  ts  timestamp
);
CREATE TABLE
> insert into d3.t3 values (1, '2025-01-01 12:00:00'),(2, '2025-01-02 12:00:00');
INSERT 2
> SET @dxy11 = 5;
SET
> CREATE TRIGGER trig_dxy11
    BEFORE UPDATE ON d3.t3
    FOR EACH ROW
    $$ BEGIN
SELECT id INTO @dxy11 FROM d3.t3 WHERE id=1 LIMIT 1;END $$;
CREATE TRIGGER
> UPDATE d3.t3 SET id=200 where ts > '2025-01-02 10:00:00';
UPDATE 1
> select @dxy11;
  @dxy11
----------
       1
(1 row)
> DROP DATABASE IF EXISTS d3 cascade;
DROP DATABASE
